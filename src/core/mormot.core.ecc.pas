/// Framework Core High-Level Public-Key Elliptic-Curve Cryptography
// - this unit is a part of the Open Source Synopse mORMot framework 2,
// licensed under a MPL/GPL/LGPL three license - see LICENSE.md
unit mormot.core.ecc;

{
  *****************************************************************************

   Certificate-based Public Key Cryptography Classes
    - High-Level Certificate-based Public Key Cryptography
    - IProtocol Implemented using Public Key Cryptography

  *****************************************************************************
}

interface

{$I ..\mormot.defines.inc}

uses
  classes,
  sysutils,
  mormot.core.base,
  mormot.core.os,
  mormot.core.crypto,
  mormot.core.unicode,
  mormot.core.text,
  mormot.core.buffers,
  mormot.core.data,
  mormot.core.datetime,
  mormot.core.secure,
  mormot.core.variants,
  mormot.core.json,
  mormot.core.rtti,
  mormot.core.search,
  mormot.core.ecc256r1;



{ ***************** High-Level Certificate-based Public Key Cryptography }

type
  /// the known algorithms implemented in ECIES encryption
  //
  // - supports AES 256-bit encryption with safe block modes (weack ECB mode
  // is not available) - or AES 128-bit if needed (e.g. for regulatory issues)
  // - safe HMAC SHA-256 is used as MAC algorithm, or AES-GCM
  // - optional SynLZ compression can be enabled
  TEciesAlgo = (
    ecaUnknown,
    ecaPBKDF2_HMAC_SHA256_AES256_CFB,
    ecaPBKDF2_HMAC_SHA256_AES256_CBC,
    ecaPBKDF2_HMAC_SHA256_AES256_OFB,
    ecaPBKDF2_HMAC_SHA256_AES256_CTR,
    ecaPBKDF2_HMAC_SHA256_AES256_CFB_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES256_CBC_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES256_OFB_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES256_CTR_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES128_CFB_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES128_CBC_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES128_OFB_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES128_CTR_SYNLZ,
    ecaPBKDF2_HMAC_SHA256_AES128_CFB,
    ecaPBKDF2_HMAC_SHA256_AES128_CBC,
    ecaPBKDF2_HMAC_SHA256_AES128_OFB,
    ecaPBKDF2_HMAC_SHA256_AES128_CTR,
    ecaPBKDF2_AES128_GCM,
    ecaPBKDF2_AES256_GCM,
    ecaPBKDF2_AES128_GCM_SYNLZ,
    ecaPBKDF2_AES256_GCM_SYNLZ,
    ecaPBKDF2_AES128_CTRCRC,
    ecaPBKDF2_AES256_CTRCRC,
    ecaPBKDF2_AES128_CTRCRC_SYNLZ,
    ecaPBKDF2_AES256_CTRCRC_SYNLZ);

  /// binary header of a .synecc file, encrypted via ECC secp256r1
  // - as generated by TEccCertificate.Encrypt/EncryptFile, and decoded by
  // TEccCertificateSecret.Decrypt
  // - a sign-then-encrypt pattern may have been implemented for additional safety
  TEciesHeader = packed record
    /// contains 'SynEccEncrypted'#26
    // - so every .synecc file starts with those characters as signature
    magic: THash128;
    /// TEccCertificate.Issuer of the recipient public key used for encryption
    // - is either geniune random bytes, or some Baudot-encoded text
    rec: TEccCertificateIssuer;
    /// TEccCertificate.Serial of the recipient public key used for encryption
    recid: TEccCertificateID;
    /// the size of the plain content (may be compressed before encryption)
    size: cardinal;
    /// when this encryption was performed
    date: TEccDate;
    /// optional timestamp, in Unix seconds since 1970, of the source file
    unixts: cardinal;
    /// actual encryption algorithm used
    algo: TEciesAlgo;
    /// the genuine random public key used for encryption
    rndpub: TEccPublicKey;
    /// optional ECDSA secp256r1 digital signature of the plain content
    sign: TEccSignatureCertifiedContent;
    /// the Message Authentication Code of the encrypted content
    hmac: THash256;
    /// a crc32c hash of the header (excluding this field)
    crc: cardinal;
  end;

  /// points to the binary header of a .synecc encrypted file
  PEciesHeader = ^TEciesHeader;

function ToText(algo: TEciesAlgo): PShortString; overload;

/// validate the binary header of a .synecc file buffer, encrypted via ECC secp256r1
// - will check against the expected layout, and values stored (e.g. crc)
// - returns true if head is a valid .synecc header, false otherwise
function EciesHeader(const head: TEciesHeader): boolean; overload;

/// extract the binary header of a .synecc file buffer, encrypted via ECC secp256r1
// - match the format generated by TEccCertificate.Encrypt/EncryptFile
// - returns true on success, false otherwise
function EciesHeader(const encrypted: RawByteString;
  out head: TEciesHeader): boolean; overload;

/// extract the binary header of a .synecc file, encrypted via ECC secp256r1
// - match the format generated by TEccCertificate.Encrypt/EncryptFile
// - returns true on success, false otherwise
// - if rawencryptedfile is specified, will also create such a file with the
// raw encrypted content (i.e. excluding the encryptedfile header)
function EciesHeaderFile(const encryptedfile: TFileName; out head: TEciesHeader;
  const rawencryptedfile: TFileName = ''): boolean;

/// convert the binary header of a .synecc file buffer into a JSON object
// - returns '' if the header is not a valid .synecc file
function EciesHeaderText(const head: TEciesHeader): RawUtf8; overload;

/// convert the header of a .synecc file into a JSON object
// - returns '' if the header is not a valid .synecc file
// - if rawencryptedfile is specified, will also create such a file with the
// raw encrypted content (i.e. excluding the encryptedfile header)
function EciesHeaderText(const encryptedfile: TFileName;
  const rawencryptedfile: TFileName = ''): RawUtf8; overload;


const
  DEFAULT_ECCROUNDS = 60000;


type
  /// exception class associated with this mormot.core.ecc unit
  EECCException = class(ESynException);

  TEccSignatureCertified = class;

  /// a public certificate using ECC secp256r1 cryptography
  // - implements a custom binary format, with validation period, and chaining
  // - could be used for safe data signing, and authentication
  // - in fact, Base64 published property is enough to persist this instance:
  // but consider also ToBase64/FromBase64/LoadFromStream/SaveToStream methods
  TEccCertificate = class(TSynPersistent)
  protected
    fContent: TEccCertificateContent;
    fStoreOnlyPublicKey: boolean;
    function GetAuthorityIssuer: RawUtf8;
    function GetAuthoritySerial: RawUtf8;
    function GetIssueDate: RawUtf8;
    function GetIssuer: RawUtf8;
    function GetSerial: RawUtf8;
    function GetValidityEnd: RawUtf8;
    function GetValidityStart: RawUtf8;
    function GetIsSelfSigned: boolean;
    function InternalLoad(const data: RawByteString): boolean; virtual;
    function InternalSave: RawByteString; virtual;
    procedure SetBase64(const base64: RawUtf8);
  public
    /// initialize this certificate
    constructor Create; override;
    /// initialize this certificate from a supplied certificate binary
    // - will raise an EECCException if the supplied binary is incorrect
    constructor CreateFrom(const binary: TEccCertificateContent); virtual;
    /// initialize this certificate from a supplied base-64 encoded binary
    // - will raise an EECCException if the supplied base64 is incorrect
    constructor CreateFromBase64(const base64: RawUtf8); virtual;
    /// initialize this certificate from a set of potential inputs
    // - will first search from a .public file name, base-64 encoded binary,
    // or a serial number which be used to search for a local .public file
    // (as located by EccKeyFileFind)
    // - will raise an EECCException if no supplied media is correct
    constructor CreateFromAuth(const AuthPubKey: TFileName; const AuthBase64,
      AuthSerial: RawUtf8); virtual;
    /// the certification information, digitaly signed in the Signature field
    property Signed: TEccCertificateSigned
      read fContent.Signed;
    /// SHA-256 + ECDSA secp256r1 signature of the Certificate record
    property Signature: TEccSignature
      read fContent.Signature;
    /// persist the certificate as some base-64 encoded binary
    // - will use SaveToStream serialization
    function ToBase64: RawUtf8;
    /// retrieve the certificate from some base-64 encoded binary
    // - will use LoadFromStream serialization
    // - returns true on success, false otherwise
    function FromBase64(const base64: RawUtf8): boolean;
    /// retrieve the certificate from the "Base64": JSON entry of a .public file
    // - will use FromBase64/LoadFromStream serialization
    // - returns true on success, false otherwise
    function FromFile(const filename: TFileName): boolean;
    /// retrieve the certificate from a set of potential inputs
    // - will first search from a .public file name, base-64 encoded binary,
    // or a serial number which be used to search for a local .public file in
    // the current folder or EccKeyFileFolder (as located by EccKeyFileFind)
    // - returns true on success, false otherwise
    function FromAuth(const AuthPubKey: TFileName; const AuthBase64,
      AuthSerial: RawUtf8): boolean;
    /// persist only the public certificate as some base-64 encoded binary
    // - will follow TEccCertificate.SaveToStream/ToBase64 serialization,
    // even when called from a TEccCertificateSecret instance
    // - could be used to safely publish the public information of a newly
    // created certificate
    function PublicToBase64: RawUtf8;
    /// persist the certificate as some binary
    // - returns true on success (i.e. this class stores a certificate),
    // false otherwise
    function SaveToStream(Stream: TStream): boolean;
    /// retrieve the certificate from some base-64 encoded binary
    // - returns true on success, false otherwise
    function LoadFromStream(Stream: TStream): boolean;
    /// fast check of the binary buffer storage of this certificate
    // - ensure Content.CRC has the expected value, using FNV-1a checksum
    // - does not validate the certificate against the certificates chain, nor
    // perform any ECC signature: use TEccCertificateChain.IsValid instead
    function CheckCRC: boolean;
    /// encrypt using the ECIES scheme, using this public certificate as key,
    // via AES-256-CFB/PKCS7 over PBKDF2_HMAC_SHA256, and HMAC_SHA256
    // - returns the encrypted content, in the .synecc optimized format
    // - optional salt information used for PBKDF2 or HMAC can be customized
    // - ecaUnknown algorithm will use either ecaPBKDF2_HMAC_SHA256_AES256_CFB
    // or ecaPBKDF2_HMAC_SHA256_AES256_CFB_SYNLZ depending if the supplied
    // contain is compressible or not - but you may force another algorithm
    // - you can optionally associate an ECDSA secp256r1 digital signature,
    // and a timestamp which may be used when re-creating a decyphered file
    // - use TEccCertificateSecret.Decrypt to uncypher the resulting content
    function Encrypt(const Plain: RawByteString; Signature:
      TEccSignatureCertified = nil; FileDateTime: TDateTime = 0;
      const KDFSalt: RawUtf8 = 'salt'; KDFRounds: integer = DEFAULT_ECCROUNDS;
      const MACSalt: RawUtf8 = 'hmac'; MACRounds: integer = 100;
      Algo: TEciesAlgo = ecaUnknown): RawByteString;
    /// encrypt a file using the ECIES scheme, using this public certificate as
    // key,via AES-256-CFB/PKCS7 over PBKDF2_HMAC_SHA256, and HMAC_SHA256
    // - by default, will create a FileToCrypt.synecc encrypted file
    // - ecaUnknown algorithm will use either ecaPBKDF2_HMAC_SHA256_AES256_CFB
    // or ecaPBKDF2_HMAC_SHA256_AES256_CFB_SYNLZ depending if the supplied
    // contain is compressible or not - but you may force another algorithm
    // - any available .sign ECDSA secp256r1 digital signature file will be
    // recognized and embedded to the resulting .synecc content
    // - optional salt information used for PBKDF2 can be customized, to lock
    // the encryted file with the supplied password
    function EncryptFile(const FileToCrypt: TFileName;
      const DestFile: TFileName = ''; const Salt: RawUtf8 = 'salt';
      SaltRounds: integer = DEFAULT_ECCROUNDS; Algo: TEciesAlgo = ecaUnknown;
      IncludeSignFile: boolean = true): boolean;
    /// returns a TDocVariant object of all published properties of this instance
    // - excludes the Base64 property content if withBase64 is set to false
    function ToVariant(withBase64: boolean = true): variant;
    /// save the public key as a .public json file
    // - i.e. a json containing all published properties of this instance
    // - persist ToVariant() as an human-readable JSON file
    function ToFile(const filename: TFileName): boolean;
    /// low-level access to the binary buffer used ECC secp256r1 cryptography
    // - you should not use this property, but other methods
    property Content: TEccCertificateContent
      read fContent write fContent;
  published
    /// the TEccCertificate format version
    // - currently equals 1
    property Version: word
      read fContent.Version;
    /// the genuine identifier of this certificate, as hexadecimal text
    property Serial: RawUtf8
      read GetSerial;
    /// identify the certificate issuer, as text
    property Issuer: RawUtf8
      read GetIssuer;
    /// when this certificate was generated, as ISO-8601 text
    property IssueDate: RawUtf8
      read GetIssueDate;
    /// valid not before this date, as ISO-8601 text
    property ValidityStart: RawUtf8
      read GetValidityStart;
    /// valid not after this date, as ISO-8601 text
    property ValidityEnd: RawUtf8
      read GetValidityEnd;
    /// hexadecimal text of the authority certificate identifier used for signing
    property AuthoritySerial: RawUtf8
      read GetAuthoritySerial;
    /// identify the authoritify issuer used for signing, as text
    property AuthorityIssuer: RawUtf8
      read GetAuthorityIssuer;
    /// if this certificate has been signed by itself
    // - a self-signed certificate will have its AuthoritySerial/AuthorityIssuer
    // fields matching Serial/Issuer, and should be used as "root" certificates
    property IsSelfSigned: boolean
      read GetIsSelfSigned;
    /// base-64 encoded text of the whole certificate binary information
    // - only the public part of the certificate will be shown: any private key
    // of a TEccCertificateSecret instance would be trimmed
    property Base64: RawUtf8
      read PublicToBase64 write SetBase64;
  end;

  /// used to store a list of TEccCertificate instances
  // - e.g. in TEccCertificateChain.Items
  TEccCertificateObjArray = array of TEccCertificate;

  /// a public/private certificate using ECC secp256r1 cryptography
  // - will store TEccCertificate public and associated private secret key
  // - implements a custom binary format, with validation period, and chaining
  // - could be used for safe data signing via SignToBase64/SignFile, and
  // authentication / key derivation
  // - allows optional anti-forensic diffusion during storage via AFSplitStripes
  TEccCertificateSecret = class(TEccCertificate)
  protected
    fPrivateKey: TEccPrivateKey;
    fAFSplitStripes: integer;
    function InternalLoad(const data: RawByteString): boolean; override;
    function InternalSave: RawByteString; override;
  public
    /// generate a new certificate, signed using the supplied Authority
    // - if Authority is nil, will generate a self-signed certificate
    // - the supplied Issuer name would be stored using AsciiToBaudot(),
    // truncated to the Issuer buffer size, i.e. 16 bytes - if Issuer is '',
    // TAesPrng.Fill() will be used
    // - you may specify some validity time range, if needed
    // - default ParanoidVerify=true will validate the certificate digital
    // signature via a call ecdsa_verify() to ensure its usefulness
    // - would take around 4 ms under a 32-bit compiler, and 1 ms under 64-bit
    constructor CreateNew(Authority: TEccCertificateSecret;
      const IssuerText: RawUtf8 = ''; ExpirationDays: integer = 0;
      StartDate: TDateTime = 0; ParanoidVerify: boolean = true);
    /// create a certificate with its private secret key from a password-protected
    // secure binary buffer
    // - perform all reverse steps from SaveToSecureBinary() method
    // - will raise an EECCException if the supplied Binary is incorrect
    constructor CreateFromSecureBinary(const Binary: RawByteString;
      const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil); overload;
    /// create a certificate with its private secret key from a password-protected
    // secure binary buffer
    // - may be used on a constant array in executable, created via SaveToSource()
    // - perform all reverse steps from SaveToSecureBinary() method
    // - will raise an EECCException if the supplied Binary is incorrect
    constructor CreateFromSecureBinary(Data: pointer; Len: integer;
      const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil); overload;
    /// create a certificate with its private secret key from an encrypted
    // secure .private binary file and its associated password
    // - perform all reverse steps from SaveToSecureFile() method
    // - will raise an EECCException if the supplied file is incorrect
    constructor CreateFromSecureFile(const FileName: TFileName;
      const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil); overload;
    /// create a certificate with its private secret key from an encrypted
    // secure .private binary file stored in a given folder
    // - overloaded constructor retrieving the file directly from its folder
    // - perform all reverse steps from SaveToSecureFile() method
    // - will raise an EECCException if the supplied file is incorrect
    constructor CreateFromSecureFile(const FolderName: TFileName;
      const Serial, PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil); overload;
    /// finalize the instance, and safe erase fPrivateKey stored buffer
    destructor Destroy; override;
    /// returns TRUE if the private secret key is not filled with zeros
    function HasSecret: boolean;
    /// computes the 'Serial.private' file name of this certificate
    // - as used by SaveToSecureFile()
    function SaveToSecureFileName(FileNumber: integer = 0): TFileName;
    /// backup the private secret key into an encrypted .private binary file
    // - you should keep all your private keys in a safe dedicated folder
    // - filename will be the certificate hexadecimal as 'Serial.private'
    // - will use anti-forensic diffusion of the private key (64 stripes = 2KB)
    // - then AES-256-CFB encryption (or the one specified in AES parameter) will
    // be performed from PBKDF2_HMAC_SHA256 derivation of an user-supplied password
    function SaveToSecureFile(const PassWord: RawUtf8;
      const DestFolder: TFileName; AFStripes: integer = 64;
      Pbkdf2Round: integer = DEFAULT_ECCROUNDS; AES: TAesAbstractClass = nil;
      NoHeader: boolean = false): boolean;
    /// backup the private secret key into several encrypted -###.private binary files
    // - secret sharing can be used to store keys at many different places, e.g.
    // on several local or remote drives, and therefore enhance privacy and safety
    // - it will use anti-forensic diffusion of the private key to distribute it
    // into pieces, in a manner that a subset of files can not regenerate the key:
    // as a result, a compromission of one sub-file won't affect the secret key
    // - filename will be the certificate hexadecimal as 'Serial-###.private'
    // - AES-256-CFB encryption (or the one specified in AES parameter) will be
    // performed from PBKDF2_HMAC_SHA256 derivation of an user-supplied password
    function SaveToSecureFiles(const PassWord: RawUtf8;
      const DestFolder: TFileName; DestFileCount: integer;
      AFStripes: integer = 64; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil; NoHeader: boolean = false): boolean;
    /// read a private secret key from an encrypted .private binary file
    // - perform all reverse steps from SaveToSecureFile() method
    // - returns TRUE on success, FALSE otherwise
    function LoadFromSecureFile(const FileName: TFileName;
      const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil): boolean;
    /// backup the private secret key into an encrypted secure binary buffer
    // - you should keep all your private keys in a safe place
    // - will use anti-forensic diffusion of the private key (64 stripes = 2KB)
    // - then AES-256-CFB encryption (or the one specified in AES parameter) will
    // be performed from PBKDF2_HMAC_SHA256 derivation of an user-supplied password
    function SaveToSecureBinary(const PassWord: RawUtf8; AFStripes: integer = 64;
      Pbkdf2Round: integer = DEFAULT_ECCROUNDS; AES: TAesAbstractClass = nil;
      NoHeader: boolean = false): RawByteString;
    /// backup the private secret key into an encrypted source code constant
    // - may be used to integrate some private keys within an executable
    // - if ConstName='', _HEXASERIAL will be used, from 24 first chars of Serial
    // - the password may also be included as ConstName_PASS associated constant,
    // and as ConstName_CYPH in TSynPersistentWithPassword/TEccCertificateSecretSetting
    // encrypted format
    function SaveToSource(const ConstName, Comment, PassWord: RawUtf8;
      IncludePassword: boolean = true; AFStripes: integer = 0;
      Pbkdf2Round: integer = 100; AES: TAesAbstractClass = nil;
      IncludeRaw: boolean = true): RawUtf8;
    /// read a private secret key from an encrypted secure binary buffer
    // - perform all reverse steps from SaveToSecureBinary() method
    // - returns TRUE on success, FALSE otherwise
    function LoadFromSecureBinary(const Binary: RawByteString;
       const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
       AES: TAesAbstractClass = nil): boolean; overload;
    /// read a private secret key from an encrypted secure binary buffer
    // - perform all reverse steps from SaveToSecureBinary() method
    // - returns TRUE on success, FALSE otherwise
    function LoadFromSecureBinary(Data: pointer; Len: integer;
      const PassWord: RawUtf8; Pbkdf2Round: integer = DEFAULT_ECCROUNDS;
      AES: TAesAbstractClass = nil): boolean; overload;
  public
    /// compute a base-64 encoded signature of some digital content
    // - memory buffer will be hashed using SHA-256, then will be signed using
    // ECDSA over the private secret key of this certificate instance
    // - you could later on verify this text signature according to the public
    // key of this certificate, calling TEccCertificateChain.IsSigned()
    // - create internally a temporary TEccSignatureCertified instance
    function SignToBase64(Data: pointer; Len: integer): RawUtf8; overload;
    /// compute a base-64 encoded signature of some digital content hash
    // - signature will be certified by private secret key of this instance
    // - you could later on verify this text signature according to the public
    // key of this certificate, calling TEccCertificateChain.IsSigned()
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - create internally a temporary TEccSignatureCertified instance
    function SignToBase64(const Hash: THash256): RawUtf8; overload;
    /// compute a .sign digital signature of any file
    // - SHA-256/ECDSA digital signature is included in a JSON document
    // - you can set some additional metadata information for the "meta": field
    // - will raise an EECCException if FileToSign does not exist
    // - returns the .sign file name, which is in fact FileToSign+'.sign'
    // - use TEccSignatureCertifiedFile class to load and validate such files
    function SignFile(const FileToSign: TFileName;
      const MetaNameValuePairs: array of const): TFileName;
    /// decrypt using the ECIES scheme, using this private certificate as key,
    // via AES-256-CFB/PKCS7 over PBKDF2_HMAC_SHA256, and HMAC_SHA256
    // - expects TEccCertificate.Crypt() cyphered content with its public key
    // - returns the decrypted content, or '' in case of failure
    // - optional shared information used for PBKDF2 or HMAC can be customized
    // - optionally, you can retrieve the sign-then-encrypt ECDSA secp256r1
    // signature and metadata stored in the header (to be checked via
    // TEccCertificateChain.IsSigned method), and/or the associated file timestamp
    function Decrypt(const Encrypted: RawByteString;
      out Decrypted: RawByteString; Signature: PEccSignatureCertifiedContent = nil;
      MetaData: PRawJson = nil; FileDateTime: PDateTime = nil;
      const KDFSalt: RawUtf8 = 'salt'; KDFRounds: integer = DEFAULT_ECCROUNDS;
      const MACSalt: RawUtf8 = 'hmac'; MACRounds: integer = 100): TEccDecrypt;
    /// decrypt using the ECIES scheme, using this private certificate as key,
    /// decrypt a file using the ECIES scheme, using this private certificate as
    // key, via AES-256-CFB/PKCS7 over PBKDF2_HMAC_SHA256, and HMAC_SHA256
    // - makes the reverse operation of TEccCertificate.EncryptFile method
    // - by default, will erase the (.synecc) extension to FileToDecrypt name
    // - optional salt information used for PBKDF2 can be customized, to unlock
    // the encryted file with the supplied password
    // - optionally, you can retrieve the sign-then-encrypt ECDSA secp256r1
    // signature stored in the header for TEccCertificateChain.IsSigned() in
    // supplied Signature^ and MetaData^ values
    function DecryptFile(const FileToDecrypt: TFileName;
      const DestFile: TFileName = ''; const Salt: RawUtf8 = 'salt';
      SaltRounds: integer = DEFAULT_ECCROUNDS;
      Signature: PEccSignatureCertifiedContent = nil;
      MetaData: PRawJson = nil): TEccDecrypt;
  public
    /// how many anti-forensic diffusion stripes are used for private key storage
    // - default is 0, meaning no diffusion, i.e. 32 bytes of storage space
    // - you may set e.g. to 32 to activate safe diffusion to 1KB of storage
    // for ToBase64/SaveToStream methods
    // - is modified temporarly by SaveToSecure() method
    property AFSplitStripes: integer
      read fAFSplitStripes;
    /// disable private secret key storage in SaveToStream()
    // - default is false, i.e. the private secret key will be serialized
    // - you may set TRUE here so that SaveToStream() would store only the
    // public certificate, as expected by a TEccCertificate class
    // - is used e.g. by PublicToBase64 method to trim the private information
    property StoreOnlyPublicKey: boolean
      read fStoreOnlyPublicKey write fStoreOnlyPublicKey;
    /// read access to the low-level stored private key 
    property PrivateKey: TEccPrivateKey
      read fPrivateKey;
  end;

  /// store settings pointing to a local .private file containing a secret key
  // - following TEccCertificateSecret secure binary file format
  // - you may use "ECC infocrypt" command to retrieve SaveToSource constants
  TEccCertificateSecretSetting = class(TSynPersistentWithPassword)
  protected
    fSerial: RawUtf8;
    fFileName: TFileName;
    fPasswordRounds: integer;
  public
    /// initialize the settings with default values
    constructor Create; override;
    /// generate a TEccCertificateSecret instance corresponding to the settings
    // - is a wrapper around TEccCertificateSecret.CreateFromSecureFile
    // - will read the FileName file (if supplied), or search for the
    // <Serial>.private file in the supplied folder otherwise, then
    // use associated Password/PasswordRounds values to uncypher it
    // - returns nil if Serial and FileName are '', or raise an exception
    // on unexpected error
    // - caller is responsible of freeing the returned class instance
    function CertificateSecret(const FolderName: TFileName): TEccCertificateSecret;
  published
    /// the first characters of the .private file holding the secret key
    // - equals '' by default, meaning no private secret is defined
    // - you may use the FileName property instead to specify a full path name
    property Serial: RawUtf8
      read fSerial write fSerial;
    /// the first characters of the .private file holding the secret key
    // - equals '' by default, meaning no private secret is defined
    // - you may use the Serial property instead to search in an application
    // specific folder
    property FileName: TFileName
      read fFileName write fFileName;
    /// the password used to protect the .private file
    // - matches the -authpass parameter used with "ECC decrypt" command, but
    // with TSynPersistentWithPassword encryption
    // - i.e. matches ConstName_CYPH as generated by TEccCertificateSecret.SaveToSource
    property Password: SpiUtf8
      read fPassword write fPassword;
    /// number of PBKDF2 rounds to be applied to the associated password
    // - matches ConstName_ROUNDS as generated by TEccCertificateSecret.SaveToSource
    // - matches the -authrounds parameter used with "ECC decrypt" command
    // - default is DEFAULT_ECCROUNDS, i.e. 60000
    property PasswordRounds: integer
      read fPasswordRounds write fPasswordRounds;
  end;

  /// store settings pointing to a local .private file containing a secret key
  // for .synecc file decryption
  // - following TEccCertificateSecret secure binary file format
  // - publishes Salt and SaltRounds values, as expected by
  // TEccCertificateSecret.Decrypt method
  TEccCertificateDecryptSetting = class(TEccCertificateSecretSetting)
  protected
    fSalt: RawUtf8;
    fSaltRounds: integer;
  public
    /// initialize the settings with default values
    constructor Create; override;
  published
    /// the Salt passphrase used to protect the .synecc encrypted file
    // - matches the -saltpass parameter used with "ECC crypt" command
    // - default is 'salt'
    property Salt: RawUtf8
      read fSalt write fSalt;
    /// number of PBKDF2 rounds to be applied to the associated Salt
    // - matches the -saltrounds parameter used with "ECC crypt" command
    // - default is DEFAULT_ECCROUNDS, i.e. 60000
    property SaltRounds: integer
      read fSaltRounds write fSaltRounds;
  end;

  /// a ECDSA secp256r1 digital signature of some content, signed by an authority
  TEccSignatureCertified = class(TSynPersistent)
  protected
    fContent: TEccSignatureCertifiedContent;
    function GetAuthorityIssuer: RawUtf8;
    function GetAuthoritySerial: RawUtf8;
    function GetDate: RawUtf8;
  public
    /// initialize this signature
    constructor Create; override;
    /// compute a new signature of some digital content
    // - memory buffer will be hashed using SHA-256, then will be signed using
    // ECDSA over the private secret key of the supplied Authority certificate
    constructor CreateNew(Authority: TEccCertificateSecret;
      Data: pointer; Len: integer); overload;
    /// compute a new signature of some digital content hash
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - the hash will be signed using ECDSA over the private secret key of
    // the supplied Authority certificate
    constructor CreateNew(Authority: TEccCertificateSecret; const Hash: THash256); overload;
    /// initialize this signature from a supplied binary
    // - will raise an EECCException if the supplied binary content is incorrect
    constructor CreateFrom(const binary: TEccSignatureCertifiedContent;
      NoException: boolean = false);
    /// initialize this signature from a supplied base-64 encoded binary
    // - will raise an EECCException if the supplied base64 is incorrect
    constructor CreateFromBase64(const base64: RawUtf8;
      NoException: boolean = false);
    /// initialize this signature from the "sign": field of a JSON .sign file
    // - will raise an EECCException if the supplied file is incorrect
    constructor CreateFromFile(const signfilename: TFileName;
      NoException: boolean = false);
    /// fast check of the binary buffer storage of this signature
    // - performs basic checks, avoiding any void date, authority or signature
    // - use Verify() or TEccCertificateChain.IsSigned() methods for full
    // digital signature validation
    function Check: boolean;
    /// check if this digital signature matches a given data hash
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the supplied signing authority
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - this method is thread-safe, and not blocking
    function Verify(Authority: TEccCertificate;
      const hash: THash256): TEccValidity; overload;
    /// check if this digital signature matches a given memory buffer
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the supplied signing authority
    // - will compute and verify the SHA-256 hash of the supplied data
    // - this method is thread-safe, and not blocking
    function Verify(Authority: TEccCertificate;
      Data: pointer; Len: integer): TEccValidity; overload;
    /// persist the signature as some base-64 encoded binary
    function ToBase64: RawUtf8;
    /// returns a TDocVariant object of all published properties of this instance
    function ToVariant: variant; virtual;
    /// retrieve the signature from some base-64 encoded binary
    // - returns true on success, false otherwise
    function FromBase64(const base64: RawUtf8): boolean;
    /// retrieve the signature from the "sign": field of a JSON .sign file
    // - returns true on success, false otherwise
    function FromFile(const signfilename: TFileName): boolean; virtual;
    /// save the ECDSA signature into a ASN.1's binary DER buffer
    // - note that DER content only stores the ECDSA digital signature, so
    // all certification information is lost
    function SaveToDERBinary: RawByteString;
    /// save the ECDSA signature into a ASN.1's binary DER file
    // - note that DER content only stores the ECDSA digital signature, so
    // all certification information is lost - consider using
    // TEccSignatureCertifiedFile instead
    // - returns TRUE on success, FALSE otherwise
    function SaveToDERFile(const FileName: TFileName): boolean;
    /// low-level access to the binary buffer used ECDSA secp256r1 cryptography
    // - you should not use this property, but other methods
    property Content: TEccSignatureCertifiedContent
      read fContent write fContent;
  published
    /// the TEccSignatureCertified format version
    // - currently equals 1
    property Version: word
      read fContent.Version;
    /// when this signature was generated, as ISO-8601 text
    property Date: RawUtf8
      read GetDate;
    /// hexadecimal text of the authority certificate identifier used for signing
    property AuthoritySerial: RawUtf8
      read GetAuthoritySerial;
    /// identify the authoritify issuer used for signing, as text
    property AuthorityIssuer: RawUtf8
      read GetAuthorityIssuer;
  end;

  /// handle a .sign file content as generated by TEccCertificateSecret.SignFile
  // - JSON document of a SHA-256/ECDSA secp256r1 digital signature
  TEccSignatureCertifiedFile = class(TEccSignatureCertified)
  protected
    fLowLevelInfo: TDocVariantData;
    fMd5Digest: TMd5Digest;
    fSha256Digest: TSha256Digest;
    fMetaData: variant;
    fSize: integer;
    fMD5: RawUtf8;
    fSHA256: RawUtf8;
  public
    /// create and set .sign fields after TEccCertificateSecret.Decrypt() process
    // - will compute Size, and MD5/SHA-256 hashes from aDecryptedContent
    // - will raise an EECCException if the supplied parameters are incorrect
    constructor CreateFromDecryptedFile(const aDecryptedContent: RawByteString;
      const Signature: TEccSignatureCertifiedContent; const MetaData: RawJson);
    /// read a .sign digital signature file
    // - as previously generated by TEccCertificateSecret.SignFile
    // - will append '.sign' to aFileName, if it does not match this extension
    // - returns true on success, false otherwise
    function FromFile(const aFileName: TFileName): boolean; override;
    /// read a .sign digital signature JSON content
    // - as previously generated by TEccCertificateSecret.SignFile
    // - returns true on success, false otherwise
    function FromFileJson(const aFileContent: RawUtf8): boolean;
    /// compute .sign fields after TEccCertificateSecret.Decrypt() process
    // - will compute Size, and MD5/SHA-256 hashes from aDecryptedContent
    function FromDecryptedFile(const aDecryptedContent: RawByteString;
      const Signature: TEccSignatureCertifiedContent; const MetaData: RawJson): boolean;
    /// low-level access to the whole JSON document members
    property LowLevelInfo: TDocVariantData
      read fLowLevelInfo;
    /// the MD5 binary hash as stored in the .sign file
    property Md5Digest: TMd5Digest
      read fMd5Digest;
    /// the SHA-256 binary hash as stored in the .sign file
    property Sha256Digest: TSha256Digest
      read fSha256Digest;
  published
    /// the meta data document as stored in the .sign file
    property MetaData: variant
      read fMetaData;
    /// the signed file size in bytes, as stored in the .sign file
    property Size: integer
      read fSize;
    /// the MD5 hexadecimal signature as stored in the .sign file
    property MD5: RawUtf8
      read fMD5;
    /// the SHA-256 hexadecimal signature as stored in the .sign file
    property SHA256: RawUtf8
      read fSHA256;
  end;

  /// manage PKI certificates using ECC secp256r1 cryptography
  // - will implement a simple and efficient public-key infrastructure (PKI),
  // based on JSON objects or even plain base-64 encoded JSON strings
  TEccCertificateChain = class(TSynPersistentLock)
  protected
    fItems: TEccCertificateObjArray;
    fIsValidCached: boolean;
    fIsValidCacheCount: integer;
    fIsValidCache: TInt64DynArray;
    function GetCount: integer;
    function InternalAdd(cert: TEccCertificate; expected: TEccValidity): integer;
    procedure SetIsValidCached(const Value: boolean);
    function IndexBySerial(const Serial: TEccCertificateID): integer;
  public
    /// initialize the certificate store from some JSON array of strings
    // - the serialization format is just a JSON array of base-64 encoded
    // certificates (with only public keys) - so diverse from CreateFromFile()
    // - will call LoadFromJson(), and raise EECCException on any error
    constructor CreateFromJson(const json: RawUtf8);
    /// initialize the certificate store from an array of base-64 encoded strings
    // - a TRawUtf8DynArray value is very convenient when storing the
    // certificates chain as part of JSON settings, e.g. TDDDAppSettings
    // - will call LoadFromArray(), and raise EECCException on any error
    constructor CreateFromArray(const values: TRawUtf8DynArray);
    /// finalize the certificate store
    destructor Destroy; override;
    /// delete all stored certificates
    // - this method is thread-safe, calling Safe.Lock/Unlock
    procedure Clear;
    /// search for a certificate from its hexadecimal text identifier
    // - this method is not thread-safe, unless you use Safe.Lock/Unlock
    function GetBySerial(const Serial: RawUtf8): TEccCertificate; overload;
    /// search for a certificate from its binary identifier
    // - this method is not thread-safe, unless you use Safe.Lock/Unlock
    function GetBySerial(const Serial: TEccCertificateID): TEccCertificate; overload;
    /// search for a certificate binary content from its binary identifier
    // - returns TRUE if the Serial identifier was found, FALSE otherwise
    // - this method is thread-safe, since it will make a private copy of the content
    function GetBySerial(const Serial: TEccCertificateID;
      out Content: TEccCertificateContent): boolean; overload;
    /// search for a certificate public key from its binary identifier
    // - returns TRUE if the Serial identifier was found, FALSE otherwise
    // - this method is thread-safe, since it will make a private copy of the key
    function GetBySerial(const Serial: TEccCertificateID;
      out PublicKey: TEccPublicKey): boolean; overload;
    /// check if the certificate is valid, against known certificates chain
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - consider setting IsValidCached property to TRUE to reduce resource use
    // - this method is thread-safe, and not blocking
    function IsValid(cert: TEccCertificate): TEccValidity; overload;
    /// check if the certificate is valid, against known certificates chain
    // - will check internal properties of the certificate (e.g. validity dates,
    // unless ignoreDate=TRUE), and validate the stored ECDSA signature
    // according to the public key of the associated signing authority (which
    // should be valid, and stored in Items[])
    // - consider setting IsValidCached property to TRUE to reduce resource use
    // - this method is thread-safe, and not blocking
    function IsValid(const content: TEccCertificateContent;
      ignoreDate: boolean = false): TEccValidity; overload;
    /// check all stored certificates and their authorization chain
    // - returns nil if all items were valid
    // - returns the list of any invalid instances
    // - do not free the returned items, since they are reference to Items[]
    function ValidateItems: TEccCertificateObjArray;
    /// check if the digital signature is recognized by the stored certificates
    // - will check that sign.AuthoritySerial is part of the Items[] list
    // - this method won't perform the ECDSA verification: use IsSigned() instead
    // - this method is thread-safe, and not blocking
    function IsAuthorized(sign: TEccSignatureCertified): boolean; overload;
    /// check if the digital signature is recognized by the stored certificates
    // - will check that sign.AuthoritySerial is part of the Items[] list
    // - this method won't perform the ECDSA verification: use IsSigned() instead
    // - this method is thread-safe, and not blocking
    function IsAuthorized(const sign: TEccSignatureCertifiedContent): boolean; overload;
    /// check if the digital signature is recognized by the stored certificates
    // - will check that the supplied base64 encoded text is a ECC signature,
    // and that its AuthoritySerial is part of the Items[] list
    // - this method won't perform the ECDSA verification: use IsSigned() instead
    // - this method is thread-safe, and not blocking
    function IsAuthorized(const base64sign: RawUtf8): boolean; overload;
    /// check if the digital signature of a given data hash is valid
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - this method is thread-safe, and not blocking
    function IsSigned(sign: TEccSignatureCertified; const hash: THash256): TEccValidity; overload;
    /// check if the digital signature of a given memory buffer is valid
    // - if sign is a TEccSignatureCertifiedFile, the Size, MD5 and SHA256 fields
    // stored in the .sign file content will be checked against the supplied data
    // before ECDSA signature, and would return ecvCorrupted on error
    // - it will then check internal properties of the certificate (e.g. validity
    // dates), and validate the stored SHA-256/ECDSA signature according to the
    // public key of the associated signing authority (stored in Items[])
    // - this method is thread-safe, and not blocking
    function IsSigned(sign: TEccSignatureCertified;
      Data: pointer; Len: integer): TEccValidity; overload;
    /// check if the digital signature file (.sign content) is valid
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - will use TEccSignatureCertifiedFile Size, MD5 and SHA256 fields,
    // so could be used without any actual memory buffer
    // - this method is thread-safe, and not blocking
    function IsSigned(sign: TEccSignatureCertifiedFile): TEccValidity; overload;
    /// check if the digital signature of a given data hash is valid
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - this method is thread-safe, and not blocking
    function IsSigned(const sign: TEccSignatureCertifiedContent;
      const hash: THash256): TEccValidity; overload;
    /// check if the digital signature of a given memory buffer is valid
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - will compute and verify the SHA-256 hash of the supplied data
    // - this method is thread-safe, and not blocking
    function IsSigned(const sign: TEccSignatureCertifiedContent;
      Data: pointer; Len: integer): TEccValidity; overload;
    /// verify the base-64 encoded digital signature of a given hash
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - supplied hash is likely to be from SHA-256, but could be e.g. crc256c
    // - this method is thread-safe, and not blocking
    function IsSigned(const base64sign: RawUtf8;
      const hash: THash256): TEccValidity; overload;
    /// verify the base-64 encoded digital signature of a given memory buffer
    // - will check internal properties of the certificate (e.g. validity dates),
    // and validate the stored ECDSA signature according to the public key of
    // the associated signing authority (which should be stored in Items[])
    // - will compute and verify the SHA-256 hash of the supplied data
    // - this method is thread-safe, and not blocking
    function IsSigned(const base64sign: RawUtf8;
      Data: pointer; Len: integer): TEccValidity; overload;
    /// register a certificate in the internal certificate chain
    // - returns the index of the newly inserted certificate
    // - returns -1 on error, e.g. if the certificate was not valid, or its
    // serial was already part of the internal list
    // - any self-signed certificate will be rejected: use AddSelfSigned() instead
    // - this method is thread-safe
    function Add(cert: TEccCertificate): integer;
    /// register a self-signed certificate in the internal certificate chain
    // - a self-signed certificate will have its AuthoritySerial/AuthorityIssuer
    // fields matching Serial/Issuer, and should be used as "root" certificates
    // - returns -1 on error, e.g. if the certificate was not valid,
    // not self-signed or its serial was already part of the internal list
    // - this method is thread-safe
    function AddSelfSigned(cert: TEccCertificate): integer;
    /// save the whole certificates chain as an array of base-64 encoded content
    // - each certificate would be stored via PublicToBase64() into a RawUtf8
    // - any private key would be trimmed from the output: private secret keys
    // should NOT be kept in the main chain, in which only public keys will appear
    function SaveToArray: TRawUtf8DynArray;
    /// load a certificates chain from an array of base-64 encoded content
    // - follows SaveToArray format
    // - would create only TEccCertificate instances with their public keys,
    // since no private key, therefore no TEccCertificateSecret is expected
    function LoadFromArray(const values: TRawUtf8DynArray): boolean;
    /// save the whole certificates chain as a JSON array
    // - each certificate would be stored via PublicToBase64() into a JSON string
    // - any private key would be trimmed from the output JSON: private secret
    // keys should NOT be kept in the main chain, in which only public keys
    // should appear
    function SaveToJson: RawUtf8;
    /// load a certificates chain from a JSON array of strings
    // - follows SaveToJson format, i.e. base-64 encoded strings
    // - would create only TEccCertificate instances with their public keys,
    // since no private key, therefore no TEccCertificateSecret is expected
    function LoadFromJson(const json: RawUtf8): boolean;
  public
    /// initialize the certificate store from some JSON-serialized .ca file
    // - the file would store plain verbose information of all certificates,
    // i.e. base-64 full information (containing only public keys) and also
    // high-level published properties of all stored certificates (e.g. Serial)
    // - as such, this file format is more verbose than CreateFromJson/SaveToJson
    // and may be convenient for managing certificates with a text/json editor
    // - you may use SaveToFile() method to create such JSON file
    // - will call LoadFromFile(), and raise EECCException on any error
    constructor CreateFromFile(const jsonfile: TFileName);
    /// initialize the certificate store from an array of .public file names
    // - raise EECCException on any error when reading a .public file
    constructor CreateFromFiles(const files: array of TFileName);
    /// save the whole certificates chain as a JSON object, matching .ca format
    // - is in fact the human-friendly JSON serialization of this instance
    // - would store plain verbose information of all certificates,
    // i.e. base-64 full information (containing only public keys) and also
    // high-level published properties of all stored certificates (e.g. Serial)
    // - as such, .ca file format is more verbose than CreateFromJson/SaveToJson
    // and may be convenient for managing certificates with a text/json editor
    function SaveToFileVariant: variant;
    /// save the whole certificates chain as a JSON content, matching .ca format
    // - is in fact the human-friendly JSON serialization of this instance
    // - would store plain verbose information of all certificates,
    // i.e. base-64 full information (containing only public keys) and also
    // high-level published properties of all stored certificates (e.g. Serial)
    // - as such, .ca file format is more verbose than CreateFromJson/SaveToJson
    // and may be convenient for managing certificates with a text/json editor
    function SaveToFileContent: RawUtf8;
    /// load a certificates chain from some JSON-serialized .ca file content
    // - you may use SaveToFileContent method to create such JSON content
    // - would create only TEccCertificate instances with their public keys,
    // since no private key, therefore no TEccCertificateSecret is expected
    function LoadFromFileContent(const cajsoncontent: RawUtf8): boolean;
    /// save the whole certificates chain as a .ca JSON file
    // - is in fact the human-friendly JSON serialization of this instance
    // - the .ca file would store plain verbose information of all certificates,
    // i.e. base-64 full information (containing only public keys) and also
    // high-level published properties of all stored certificates (e.g. Serial)
    // - as such, this file format is more verbose than CreateFromJson/SaveToJson
    // and may be convenient for managing certificates with a text/json editor
    function SaveToFile(const jsonfile: TFileName): boolean;
    /// load a certificates chain from some JSON-serialized .ca file
    // - you may use SaveToFile() method to create such JSON file
    // - would create only TEccCertificate instances with their public keys,
    // since no private key, therefore no TEccCertificateSecret is expected
    // - if jsonfile is not in the current folder, will try EccKeyFileFolder
    function LoadFromFile(const jsonfile: TFileName): boolean;
  published
    /// low-level access to the internal certificates chain
    // - thread-safe process may be done using
    // ! Safe.Lock; try ... finally Safe.Unlock; end;
    property Items: TEccCertificateObjArray
      read fItems;
    /// how many certificates are currently stored in the certificates chain
    property Count: integer
      read GetCount;
    /// if the IsValid() calls should maintain a cache of all valid certificates
    // - will use a naive but very efficient crc64c hashing of previous contents
    // - since ecdsa_verify() is very demanding, such a cache may have a huge
    // speed benefit if the certificates are about to be supplied several times
    // - is disabled by default, for paranoid safety
    property IsValidCached: boolean
      read fIsValidCached write SetIsValidCached;
  end;

const
  /// file extension of the JSON file storing a TEccCertificate public key
  ECCCERTIFICATEPUBLIC_FILEEXT = '.public';
  /// file extension of the binary encrypted file storing a private key
  // - as generated by TEccCertificateSecret.SaveToSecureFile method
  ECCCERTIFICATESECRET_FILEEXT = '.private';
  /// file extension of the JSON file storing a digital signature of a file
  // - by convention, this .sign extension is appended to the original file name
  // - as generated by TEccCertificateSecret.SignFile, and loaded by the
  // TEccSignatureCertifiedFile class
  ECCCERTIFICATESIGN_FILEEXT = '.sign';
  /// file extension of the JSON file storing a certificate authorities chain
  // - as generated by mORMot.pas TEccCertificateChainFile.SaveToFile()
  // and loaded by TEccCertificateChain.LoadFromFile
  ECCCERTIFICATES_FILEEXT = '.ca';
  /// file extension of the ECIES encrypted file
  // - with optional digital signature of the plain content
  // - as generated by TEccCertificate.Encrypt/EncryptFile, and decoded via
  // TEccCertificateSecret.Decrypt
  ENCRYPTED_FILEEXT = '.synecc';

/// search the single .public or .private file starting with the supplied file name
// - as used in the ECC.dpr command-line sample project
// - returns true and set the full file name of the matching file
// - returns false is there is no match, or more than one matching file
// - will also search in EccKeyFileFolder, if the supplied folder is not enough
function EccKeyFileFind(var TruncatedFileName: TFileName; privkey: boolean): boolean;

/// search the single .public or .private file used to crypt a given content
// - match the format generated by TEccCertificate.Encrypt/EncryptFile
// - returns true on success, false otherwise
// - will also search in EccKeyFileFolder, if the current folder is not enough
function EciesKeyFileFind(const encrypted: RawByteString; out keyfile: TFileName;
  privkey: boolean = true): boolean;

/// retrieve the private local folder used to store .public or .private files
// - it is better to store all you key files in a single place, for easier
// and safer management
// - under Windows, returns 'C:\Users\username\AppData\Local\Synopse\Keys\'
// - under Linux, returns '$HOME/.synopse/keys/'
function EccKeyFileFolder: TFileName;



{ ***************** IProtocol Implemented using Public Key Cryptography }

{
  On FPC x86_64, from our regression tests:
  - ECDHE stream protocol: 54,228 assertions passed  916.75ms
    100 efAesCrc128 in 1.56ms i.e. 63,856/s, aver. 15us, 1.1 GB/s
    100 efAesCfb128 in 1.65ms i.e. 60,386/s, aver. 16us, 1 GB/s
    100 efAesOfb128 in 2.51ms i.e. 39,824/s, aver. 25us, 734.2 MB/s
    100 efAesCtr128 in 853us i.e. 117,233/s, aver. 8us, 2.1 GB/s
    100 efAesCbc128 in 2.89ms i.e. 34,530/s, aver. 28us, 636.6 MB/s
    100 efAesCrc256 in 2.11ms i.e. 47,326/s, aver. 21us, 872.6 MB/s
    100 efAesCfb256 in 2.32ms i.e. 43,084/s, aver. 23us, 794.4 MB/s
    100 efAesOfb256 in 3.35ms i.e. 29,770/s, aver. 33us, 548.9 MB/s
    100 efAesCtr256 in 1.06ms i.e. 94,161/s, aver. 10us, 1.6 GB/s
    100 efAesCbc256 in 3.36ms i.e. 29,717/s, aver. 33us, 547.9 MB/s
    100 efAesGcm128 in 4.90ms i.e. 20,383/s, aver. 49us, 375.8 MB/s
    100 efAesGcm256 in 5.75ms i.e. 17,364/s, aver. 57us, 320.1 MB/s
    100 efAesCtc128 in 764us i.e. 130,890/s, aver. 7us, 2.3 GB/s
    100 efAesCtc256 in 965us i.e. 103,626/s, aver. 9us, 1.8 GB/s
  - if mormot.core.openssl is included, AES-GCM is much faster:
    100 efAesGcm128 in 721us i.e. 138,696/s, aver. 7us, 2.4 GB/s
    100 efAesGcm256 in 924us i.e. 108,225/s, aver. 9us, 1.9 GB/s

  On FPC i386, from our regression tests:
    100 efAesCrc128 in 2.31ms i.e. 43,159/s, aver. 23us, 795.7 MB/s
    100 efAesCfb128 in 2.40ms i.e. 41,580/s, aver. 24us, 766.6 MB/s
    100 efAesOfb128 in 3.17ms i.e. 31,525/s, aver. 31us, 581.2 MB/s
    100 efAesCtr128 in 4.08ms i.e. 24,497/s, aver. 40us, 451.6 MB/s
    100 efAesCbc128 in 5.45ms i.e. 18,341/s, aver. 54us, 338.1 MB/s
    100 efAesCrc256 in 2.95ms i.e. 33,829/s, aver. 29us, 623.7 MB/s
    100 efAesCfb256 in 2.95ms i.e. 33,863/s, aver. 29us, 624.3 MB/s
    100 efAesOfb256 in 4.02ms i.e. 24,826/s, aver. 40us, 457.7 MB/s
    100 efAesCtr256 in 4.91ms i.e. 20,333/s, aver. 49us, 374.9 MB/s
    100 efAesCbc256 in 6.68ms i.e. 14,970/s, aver. 66us, 276 MB/s
    100 efAesGcm128 in 5.54ms i.e. 18,040/s, aver. 55us, 332.6 MB/s
    100 efAesGcm256 in 6.48ms i.e. 15,427/s, aver. 64us, 284.4 MB/s
    100 efAesCtc128 in 3.53ms i.e. 28,320/s, aver. 35us, 522.1 MB/s
    100 efAesCtc256 in 4.34ms i.e. 23,036/s, aver. 43us, 424.7 MB/s
  - if mormot.core.openssl is included, AES-CTR and AES-GCM are much faster:
    100 efAesCtr128 in 1.67ms i.e. 59,630/s, aver. 16us, 1 GB/s
    100 efAesCtr256 in 1.88ms i.e. 53,134/s, aver. 18us, 0.9 GB/s
    100 efAesGcm128 in 1.72ms i.e. 57,937/s, aver. 17us, 1 GB/s
    100 efAesGcm256 in 2.02ms i.e. 49,455/s, aver. 20us, 911.8 MB/s

  Using ECDHEPROT_EF2MAC[] so weak Crc32c but for AesCrc and AesGcm
  which have their own stronger MAC computation (CRC32C+AES or GMAC).

  -> Default efAesCrc128 is safe and fast, but if OpenSSL is available,
     efAesGcm128/efAesGcm256 would be both stronger and faster.
     On Win64, efAesCtr128 may be used as fastest native cipher.
}


type
  /// the Authentication schemes recognized by TEcdheProtocol
  // - specifying the authentication allows a safe one-way handshake
  TEcdheAuth = (
    authMutual,
    authServer,
    authClient);

  /// set of Authentication schemes recognized by TEcdheProtocolServer
  TEcdheAuths = set of TEcdheAuth;

  /// the Key Derivation Functions recognized by TEcdheProtocol
  // - used to compute the EF secret and MAC secret from shared ephemeral secret
  // - only HMAC SHA-256 safe algorithm is proposed currently
  TEcdheKdf = (
    kdfHmacSha256);

  /// the Encryption Functions recognized by TEcdheProtocol
  // - all supported AES chaining blocks have their 128-bit and 256-bit flavours
  // - default efAesCrc128 (or its 256-bit efAesCrc256) will use the TAesCfbCrc
  // class, i.e. AES-CFB encryption with on-the-fly 256-bit CRC computation of
  // the plain and encrypted blocks, and AES-encryption of the CRC to ensure
  // cryptographic level message authentication and integrity - associated
  // TEcdheMac property should be macDuringEF
  // - efAesGcm128/efAesGcm256 will use TAesGcm and macDuringEF
  // - efAesCtc128/efAesCtc256 is TAesCtrCrc, so around 2GB/s on x86_64, with
  // 256-bit authentication of both plain and ciphered content
  // - other values will define TAesCfb/TAesOfb/TAesCtrNist/TAesCbc in
  // 128-bit or 256-bit mode, in conjunction with a TEcdheMac setting
  // - of course, weack ECB mode is not available
  // - adding any new ciphers to this enum needs to keep the existing
  TEcdheEF = (
    efAesCrc128,
    efAesCfb128,
    efAesOfb128,
    efAesCtr128,
    efAesCbc128,
    efAesCrc256,
    efAesCfb256,
    efAesOfb256,
    efAesCtr256,
    efAesCbc256,
    efAesGcm128,
    efAesGcm256,
    efAesCtc128,
    efAesCtc256);

  /// the Message Authentication Codes recognized by TEcdheProtocol
  // - default macDuringEF (680MB/s for efAesCrc128 with SSE4.2 and AES-NI)
  // means that no separated MAC is performed, but done during encryption step:
  // only supported by efAesCrc128/efAesCrc256 and efAesGcm128/efAesGcm256
  // - macHmacSha256 is the safest, but slow, especially when used as MAC for
  // AES-NI accellerated encryption (110MB/s with efAesCfb128, to be compared
  // with macDuringEF, which produces a similar level of MAC)
  // - macHmacCrc256c and macHmacCrc32c are faster (550-650MB/s with efAesCfb128),
  // and prevent transmission errors but not message integrity or authentication
  // since composition of two crcs is a multiplication by a polynomial - see
  // http://mslc.ctf.su/wp/boston-key-party-ctf-2016-hmac-crc-crypto-5pts
  // - macXxHash32 will use the xxhash32() algorithm, fastest without SSE4.2
  // - macNone (800MB/s, which is the speed of AES-NI encryption itself for a
  // random set of small messages) won't check errors, but only replay attacks
  TEcdheMac = (
    macDuringEF,
    macHmacSha256,
    macHmacCrc256c,
    macHmacCrc32c,
    macXxHash32,
    macNone);

  /// defines one protocol Algorithm recognized by TEcdheProtocol
  // - only safe and strong parameters are allowed, and the default values
  // (i.e. all fields set to 0) will ensure a very good combination
  // - in current implementation, there is no negociation between nodes:
  // client and server should have the very same algorithm
  TEcdheAlgo = packed record
    /// the current Authentication scheme
    auth: TEcdheAuth;
    /// the current Key Derivation Function
    kdf: TEcdheKdf;
    /// the current Encryption Function
    ef: TEcdheEF;
    /// the current Message Authentication Code
    mac: TEcdheMac;
  end;

  /// points to one protocol Algorithm recognized by TEcdheProtocol
  PECDHEAlgo = ^TEcdheAlgo;

  /// the binary handshake message, sent by client to server
  // - the frame will always have the same fixed size of 290 bytes (i.e. 388
  // base64-encoded chars, which could be transmitted in a HTTP header),
  // for both mutual or unilateral authentication
  // - ephemeral keys may be included for perfect forward security
  TEcdheFrameClient = packed record
    /// expected algorithm used
    algo: TEcdheAlgo;
    /// a client-generated random seed
    RndA: THash128;
    /// client public key, with its certificate
    // - may be zero, in case of unilateral authentication (algo=authServer)
    QCA: TEccCertificateContent;
    /// client-generated ephemeral public key
    // - may be zero, in case of unilateral authentication (algo=authClient)
    QE: TEccPublicKey;
    /// SHA-256 + ECDSA secp256r1 signature of the previous fields, computed
    // with the client private key
    // - i.e. ECDSASign(dA,sha256(algo|RndA|QCA|QE))
    // - may be zero, in case of unilateral authentication (algo=authServer)
    Sign: TEccSignature;
  end;

  /// the binary handshake message, sent back from server to client
  // - the frame will always have the same fixed size of 306 bytes (i.e. 408
  // base64-encoded chars, which could be transmitted in a HTTP header),
  // for both mutual or unilateral authentication
  // - ephemeral keys may be included for perfect forward security
  TEcdheFrameServer = packed record
    /// algorithm used by the server
    algo: TEcdheAlgo;
    /// client-generated random seed
    RndA: THash128;
    /// a server-generated random seed
    RndB: THash128;
    /// server public key, with its certificate
    // - may be zero, in case of unilateral authentication (algo=authClient)
    QCB: TEccCertificateContent;
    /// server-generated ephemeral public key
    // - may be zero, in case of unilateral authentication (algo=authServer)
    QF: TEccPublicKey;
    /// SHA-256 + ECDSA secp256r1 signature of the previous fields, computed
    // with the server private key
    // - i.e. ECDSASign(dB,sha256(algo|RndA|RndB|QCB|QF))
    // - may be zero, in case of unilateral authentication (algo=authClient)
    Sign: TEccSignature;
  end;


function ToText(algo: TEcdheAuth): PShortString; overload;
function ToText(algo: TEcdheKdf): PShortString; overload;
function ToText(algo: TEcdheEF): PShortString; overload;
function ToText(algo: TEcdheMac): PShortString; overload;

type
  /// abstract ECDHE secure protocol with unilateral or mutual authentication
  // - inherited TEcdheProtocolClient and TEcdheProtocolServer
  // classes will implement a secure client/server transmission, with a one-way
  // handshake and asymmetric encryption
  // - will validate ECDSA signatures using certificates of the associated PKI
  // - will create an ephemeral ECC key pair for perfect forward security
  // - will use ECDH to compute a shared ephemeral session on both sides,
  // for AES-128 or AES-256 encryption, and HMAC with anti-replay - default
  // algorithm will use fast and safe AES-CFB 128-bit encryption, with efficient
  // AES-CRC 256-bit MAC, and full hardware accelleration on Intel CPUs
  TEcdheProtocol = class(TInterfacedObjectLocked, IProtocol)
  protected
    fPKI: TEccCertificateChain;
    fPrivate: TEccCertificateSecret;
    fAlgo: TEcdheAlgo;
    fEFSalt: RawByteString;
    fMacSalt: RawByteString;
    fOwned: set of (ownPKI, ownPrivate);
    fCertificateValidity: TEccValidity;
    fRndA, fRndB: THash128;
    fAes: array[boolean] of TAesAbstract;
    fkM: array[boolean] of THash256Rec;
    // contains inc(PInt64(@aKey)^) to maintain RX/TX sequence number
    procedure SetKey(aEncrypt: boolean);
    procedure ComputeMAC(aEncrypt: boolean; aEncrypted: pointer; aLen: integer;
      out aMAC: THash256Rec);
    function Verify(frame: PByteArray; len: integer;
      const QC: TEccCertificateContent; out res: TProtocolResult): boolean;
    procedure Sign(frame: PByteArray; len: integer; out QC: TEccCertificateContent);
    procedure SharedSecret(sA, sB: PHash256);
  public
    /// initialize the ECDHE protocol with a PKI and a private secret key
    // - if aPKI is not set, the certificates won't be validated and the protocol
    // will allow self-signed credentials
    // - aPrivate should always be set for mutual or unilateral authentication
    // - will implement unilateral authentication if aPrivate=nil for this end
    constructor Create(aAuth: TEcdheAuth; aPKI: TEccCertificateChain;
      aPrivate: TEccCertificateSecret; aEF: TEcdheEF = efAesCrc128);
        reintroduce; overload; virtual;
    /// will create another instance of this communication protocol
    constructor CreateFrom(aAnother: TEcdheProtocol); virtual;
    /// initialize the communication by exchanging some client/server information
    // - this method should be overriden with the proper implementation
    function ProcessHandshake(const MsgIn: RawUtf8;
      out MsgOut: RawUtf8): TProtocolResult; virtual; abstract;
    /// creates a new TEcdheProtocolClient or TEcdheProtocolServer from a text key
    // - expected layout is values separated by ; with at least a=... pair
    // - if needed, you can specify p=... as the password file name (searching
    // for first matching unique file name with .private extension in the
    // current directory of in EccKeyFileFolder), and pw=...;pr=... for the
    // associated password protection (password content and rounds)
    // - optional ca=..;a=..;k=..;e=..;m=.. switches will match PKI, Auth, KDF,
    // EF and MAC properties of this class instance (triming left lowercase chars)
    // - global value set by FromKeySetCA() is used as PKI, unless ca=.. is set
    // (as a .ca file name, or as ca=base64,base64 or ca="base64","base64")
    // - a full text key with default values may be:
    // $ a=mutual;k=hmacsha256;e=aescrc128;m=duringef;p=34a2;pw=passwordFor34a2;
    // $ pr=60000;ca=websockets
    // - returns nil if aKey does not match this format, i.e. has no p=..,pw=..
    class function FromKey(const aKey: RawUtf8; aServer: boolean): TEcdheProtocol;
    /// defines the default PKI instance to be used by FromKey
    // - used if the ca=... property is not set in the aKey value
    class procedure FromKeySetCA(aPKI: TEccCertificateChain);
    /// computes a TSynPersistentWithPassword key expected by FromKey
    // - the .private key file name, and its associated password/rounds should
    // be specified, but for unilateral authentication on the other side
    // - pki should be a .ca file name, 'base64,base64' or '"base64","base64"'
    // - result of this method can be stored directly in a .settings file,
    // to enable the TEcdheProtocol safe protocol for transmission
    class function FromKeyCompute(const privkey, privpassword: RawUtf8;
      privrounds: integer = DEFAULT_ECCROUNDS; const pki: RawUtf8 = '';
      auth: TEcdheAuth = authMutual; kdf: TEcdheKdf = kdfHmacSha256;
      ef: TEcdheEF = efAesCrc128; mac: TEcdheMac = macDuringEF;
      customkey: cardinal = 0): RawUtf8;
    /// finalize the instance
    // - also erase all temporary secret keys, for safety
    destructor Destroy; override;
    /// encrypt a message on one side, ready to be transmitted to the other side
    // - will use the Encryption Function EF, according to the shared secret key
    // - this method is thread-safe
    procedure Encrypt(const aPlain: RawByteString;
      out aEncrypted: RawByteString); virtual;
    /// decrypt a message on one side, as transmitted from the other side
    // - will use the Encryption Function EF, according to the shared secret key
    // - returns sprInvalidMAC in case of wrong aEncrypted input (e.g. packet
    // corruption, MiM or Replay attacks attempts)
    // - this method is thread-safe
    function Decrypt(const aEncrypted: RawByteString;
      out aPlain: RawByteString): TProtocolResult; virtual;
    /// check for any transmission error of the supplied encrypted text
    // - returns sprSuccess if the stored CRC of the encrypted flow matches
    // - returns sprInvalidMAC in case of wrong aEncrypted input
    // - is only implemented for MAC=macDuringEF, otherwise returns sprUnsupported
    // - to be called before Decrypt(), since this later method will change the
    // internal kM[false] sequence number
    function CheckError(const aEncrypted: RawByteString): TProtocolResult; virtual;
    /// will create another instance of this communication protocol
    function Clone: IProtocol;
    /// shared public-key infrastructure, used to validate exchanged certificates
    // - will be used for authenticity validation of ECDSA signatures
    property PKI: TEccCertificateChain
      read fPKI;
    /// the current Authentication scheme
    // - this value on client side should match server's Authorized
    // - this value on server side may change if the client forced another mode
    property Auth: TEcdheAuth
      read fAlgo.auth;
    /// the current Key Derivation Function
    // - this value should match on both client and server sides
    property KDF: TEcdheKdf
      read fAlgo.kdf write fAlgo.kdf;
    /// the current salt, used by the Key Derivation Function KDF to compute the
    // key supplied to the Encryption Function EF
    // - equals 'ecdhesalt' by default
    // - this value should match on both client and server sides
    property EFSalt: RawByteString
      read fEFSalt write fEFSalt;
    /// the current Encryption Function
    // - this value should match on both client and server sides
    property EF: TEcdheEF
      read fAlgo.ef write fAlgo.ef;
    /// the current salt, used by the Key Derivation Function KDF to compute the
    // key supplied to the Message Authentication Code MAC
    // - equals 'ecdhemac' by default
    // - this value should match on both client and server sides
    property MACSalt: RawByteString
      read fMacSalt write fMacSalt;
    /// the current Message Authentication Code
    // - this value should match on both client and server sides
    property MAC: TEcdheMac
      read fAlgo.mac write fAlgo.mac;
    /// after handshake, contains the information about the other side
    // public key certificate validity, against the shared PKI
    property CertificateValidity: TEccValidity
      read fCertificateValidity;
  end;

  /// meta-class of the TEcdheProtocol type
  TEcdheProtocolClass = class of TEcdheProtocol;

  /// implements ECDHE secure protocol on client side
  TEcdheProtocolClient = class(TEcdheProtocol)
  protected
    fdE: TEccPrivateKey;
  public
    /// initialize the ECDHE protocol on the client side
    // - will check that aAuth is compatible with the supplied aPKI/aPrivate
    constructor Create(aAuth: TEcdheAuth; aPKI: TEccCertificateChain;
      aPrivate: TEccCertificateSecret; aEF: TEcdheEF = efAesCrc128);
        reintroduce; overload; virtual;
    /// generate the authentication frame sent from the client
    procedure ComputeHandshake(out aClient: TEcdheFrameClient);
    /// validate the authentication frame sent back by the server
    function ValidateHandshake(const aServer: TEcdheFrameServer): TProtocolResult;
    /// initialize the client communication
    // - if MsgIn is '', will call ComputeHandshake
    // - if MsgIn is set, will call ValidateHandshake
    function ProcessHandshake(const MsgIn: RawUtf8;
      out MsgOut: RawUtf8): TProtocolResult; override;
  end;

  /// implements ECDHE secure protocol on server side
  TEcdheProtocolServer = class(TEcdheProtocol)
  protected
    fAuthorized: TEcdheAuths;
  public
    /// initialize the ECDHE protocol on the client side
    // - will check that aAuth is compatible with the supplied aPKI/aPrivate
    constructor Create(aAuth: TEcdheAuth; aPKI: TEccCertificateChain;
      aPrivate: TEccCertificateSecret; aEF: TEcdheEF = efAesCrc128);
        reintroduce; overload; virtual;
    /// will create another instance of this communication protocol
    constructor CreateFrom(aAnother: TEcdheProtocol); override;
    /// generate the authentication frame corresponding to the client request
    // - may change Auth property if the Client requested another authentication
    // scheme, allowed in Authorized setting and compatible with fPrivate
    function ComputeHandshake(const aClient: TEcdheFrameClient;
      out aServer: TEcdheFrameServer): TProtocolResult;
    /// initialize the server communication
    // - will call ComputeHandshake
    function ProcessHandshake(const MsgIn: RawUtf8;
      out MsgOut: RawUtf8): TProtocolResult; override;
    /// the Authentication Schemes allowed by this server
    // - by default, only the aAuth value specified to Create is allowed
    // - you can set e.g. [authMutual,authServer] for a weaker pattern
    property Authorized: TEcdheAuths
      read fAuthorized write fAuthorized;
  end;


const
  /// how TEcdheProtocol.SharedSecret initialize the AES engines
  ECDHEPROT_EF2BITS: array[TEcdheEF] of integer = (
    128, 128, 128, 128, 128,
    256, 256, 256, 256, 256,
    128, 256, 128, 256);

  /// default MAC used for a given Encryption Function
  // - as used by TEcdheProtocol.Create() from its TEcdheEF parameter
  // - favor performance - you may force macHmacSha256 for cryptographic level
  ECDHEPROT_EF2MAC: array[TEcdheEF] of TEcdheMac = (
    macDuringEF, macHmacCrc32c, macHmacCrc32c, macHmacCrc32c, macHmacCrc32c,
    macDuringEF, macHmacCrc32c, macHmacCrc32c, macHmacCrc32c, macHmacCrc32c,
    macDuringEF, macDuringEF, macDuringEF, macDuringEF);



implementation

{ ***************** High-Level Certificate-based Public Key Cryptography }

function ToText(algo: TEciesAlgo): PShortString;
begin
  result := GetEnumName(TypeInfo(TEciesAlgo), ord(algo));
end;

const
  ecaFIRST = succ(low(TEciesAlgo));
  ecaLAST = high(TEciesAlgo);

  /// used by TEccCertificate.Encrypt and TEccCertificateSecret.Decrypt
  ECIES_AES: array[ecaFIRST .. ecaLAST] of TAesMode = (
    mCfb, mCbc, mOfb, mCtrNist, mCfb, mCbc, mOfb, mCtrNist,
    mCfb, mCbc, mOfb, mCtrNist, mCfb, mCbc, mOfb, mCtrNist,
    mGcm, mGcm, mGcm, mGcm, mCtrCrc, mCtrCrc, mCtrCrc, mCtrCrc);

  ECIES_AESSIZE: array[ecaFIRST .. ecaLAST] of integer = (
    256, 256, 256, 256, 256, 256, 256, 256,
    128, 128, 128, 128, 128, 128, 128, 128,
    128, 256, 128, 256, 128, 256, 128, 256);

  ECIES_MAGIC: array[0..1] of array[0..15] of AnsiChar = (
    'SynEccEncrypted'#26,
    'SynEccEncrypt01'#26);

  ECIES_SYNLZ = [
    ecaPBKDF2_HMAC_SHA256_AES256_CFB_SYNLZ ..
      ecaPBKDF2_HMAC_SHA256_AES128_CTR_SYNLZ,
    ecaPBKDF2_AES128_GCM_SYNLZ .. ecaPBKDF2_AES256_GCM_SYNLZ,
    ecaPBKDF2_AES128_CTRCRC_SYNLZ .. ecaPBKDF2_AES256_CTRCRC_SYNLZ];

  ECIES_AEAD = [ecaPBKDF2_AES128_GCM .. ecaPBKDF2_AES256_GCM_SYNLZ];

  ECIES_WITHOUTSYNLZ: array[ecaFIRST .. ecaLAST] of TEciesAlgo = (
    ecaPBKDF2_HMAC_SHA256_AES256_CFB, ecaPBKDF2_HMAC_SHA256_AES256_CBC,
    ecaPBKDF2_HMAC_SHA256_AES256_OFB, ecaPBKDF2_HMAC_SHA256_AES256_CTR,
    ecaPBKDF2_HMAC_SHA256_AES256_CFB, ecaPBKDF2_HMAC_SHA256_AES256_CBC,
    ecaPBKDF2_HMAC_SHA256_AES256_OFB, ecaPBKDF2_HMAC_SHA256_AES256_CTR,
    ecaPBKDF2_HMAC_SHA256_AES128_CFB, ecaPBKDF2_HMAC_SHA256_AES128_CBC,
    ecaPBKDF2_HMAC_SHA256_AES128_OFB, ecaPBKDF2_HMAC_SHA256_AES128_CTR,
    ecaPBKDF2_HMAC_SHA256_AES128_CFB, ecaPBKDF2_HMAC_SHA256_AES128_CBC,
    ecaPBKDF2_HMAC_SHA256_AES128_OFB, ecaPBKDF2_HMAC_SHA256_AES128_CTR,
    ecaPBKDF2_AES128_GCM, ecaPBKDF2_AES256_GCM,
    ecaPBKDF2_AES128_GCM, ecaPBKDF2_AES256_GCM,
    ecaPBKDF2_AES128_CTRCRC, ecaPBKDF2_AES128_CTRCRC,
    ecaPBKDF2_AES128_CTRCRC, ecaPBKDF2_AES128_CTRCRC);

type
  TEciesFeatures = set of (
    efMetaData);

function EciesLevel(const head: TEciesHeader): integer;
  // inline; defeats Delphi optimizer for IsEqual()
begin
  for result := 0 to high(ECIES_MAGIC) do
    if IsEqual(head.magic, THash128(ECIES_MAGIC[result])) then
      exit;
  result := -1;
end;

function EciesFeatures(const head: TEciesHeader): TEciesFeatures;
var
  level: integer;
begin
  byte(result) := 0;
  level := EciesLevel(head);
  if level > 0 then
    include(result, efMetaData);
end;

function EciesHeader(const head: TEciesHeader): boolean;
begin
  result := (EciesLevel(head) >= 0) and
    (head.Algo in [ecaFIRST .. ecaLAST]) and
    (head.crc = crc32c(PCardinal(@head.hmac)^, @head, sizeof(head) - sizeof(head.crc)));
end;

function EciesHeader(const encrypted: RawByteString; out head: TEciesHeader): boolean;
begin
  result := (length(encrypted) > sizeof(head)) and
    EciesHeader(PEciesHeader(encrypted)^);
  if result then
    head := PEciesHeader(encrypted)^;
end;

function EciesHeaderFile(const encryptedfile: TFileName; out head: TEciesHeader;
  const rawencryptedfile: TFileName): boolean;
var
  F: THandle;
  len: PtrInt;
  tmp: RawByteString;
begin
  result := false;
  if encryptedfile = '' then
    exit;
  F := FileOpen(encryptedfile, fmOpenRead or fmShareDenyNone);
  if not ValidHandle(F) then
    exit;
  if FileRead(F, head, sizeof(head)) = sizeof(head) then
    result := EciesHeader(head);
  if result and
     (rawencryptedfile <> '') then
  begin
    len := FileSize(F) - sizeof(head);
    SetLength(tmp, len);
    if FileRead(F, pointer(tmp)^, len) <> len then
      result := false
    else
      result := FileFromString(tmp, rawencryptedfile);
  end;
  FileClose(F);
end;

function EciesHeaderText(const head: TEciesHeader): RawUtf8;
var
  s: variant;
  sign: TEccSignatureCertified;
begin
  sign := TEccSignatureCertified.CreateFrom(head.sign, true);
  try
    if sign.Check then
    begin
      s := sign.ToVariant;
      _ObjAddProp('ECDSA', EccText(head.sign.Signature), s);
    end;
  finally
    sign.Free;
  end;
  with head do
    FormatUtf8('{"Date":"%","Size":%,"Recipient":"%","RecipientSerial":"%",' +
      '"FileTime":"%","Algorithm":"%","RandomPublicKey":"%","HMAC":"%",' +
      '"Signature":%,"Meta":%}', [EccText(date), size, EccText(rec),
      EccText(recid), DateTimeToIso8601Text(UnixTimeToDateTime(unixts)),
      ToText(algo)^, mormot.core.text.BinToHex(@rndpub, sizeof(rndpub)),
      Sha256DigestToString(hmac), _Safe(s)^.ToJson,
      BOOL_STR[efMetaData in EciesFeatures(head)]], result);
end;

function EciesHeaderText(const encryptedfile, rawencryptedfile: TFileName): RawUtf8;
var
  h: TEciesHeader;
begin
  if EciesHeaderFile(encryptedfile, h, rawencryptedfile) then
    result := EciesHeaderText(h)
  else
    result := '';
end;

var
  _EccKeyFileFolder: TFileName;

const
  {$ifdef OSWINDOWS}
  _KEYFILEFOLDER = 'Synopse\Keys\';
  {$else}
  _KEYFILEFOLDER = '.synopse/keys/';
  {$endif OSWINDOWS}

function EccKeyFileFolder: TFileName;
begin
  if _EccKeyFileFolder = '' then
  begin
    _EccKeyFileFolder := GetSystemPath(spUserData) + _KEYFILEFOLDER;
    if not DirectoryExists(_EccKeyFileFolder) then
      CreateDir(_EccKeyFileFolder); // always create this folder
  end;
  result := _EccKeyFileFolder;
end;

function EccKeyFileFind(var TruncatedFileName: TFileName; privkey: boolean): boolean;
var
  match: TFindFilesDynArray;
  ext, mask: TFileName;
begin
  match := nil; // to please Kylix
  if privkey then
    ext := ECCCERTIFICATESECRET_FILEEXT
  else
    ext := ECCCERTIFICATEPUBLIC_FILEEXT;
  result := true;
  if FileExists(TruncatedFileName) then
    exit;
  if FileExists(TruncatedFileName + ext) then
  begin
    TruncatedFileName := TruncatedFileName + ext;
    exit;
  end;
  mask := ExtractFileName(TruncatedFileName) + '*' + ext;
  match := FindFiles(ExtractFilePath(TruncatedFileName), mask);
  if length(match) <> 1 then
    match := FindFiles(EccKeyFileFolder, mask);
  if length(match) <> 1 then
    result := false
  else
    TruncatedFileName := match[0].Name;
end;

function EciesKeyFileFind(const encrypted: RawByteString; out keyfile: TFileName;
  privkey: boolean): boolean;
var
  head: TEciesHeader;
begin
  result := EciesHeader(encrypted, head);
  if result then
  begin
    keyfile := Utf8ToString(EccText(head.recid));
    result := EccKeyFileFind(keyfile, privkey);
  end;
end;


{ TEccCertificate }

constructor TEccCertificate.Create;
begin
  inherited Create;
  fContent.Version := 1;
end;

constructor TEccCertificate.CreateFrom(const binary: TEccCertificateContent);
begin
  Create;
  fContent := binary;
  if not EccCheck(fContent) then
    raise EECCException.CreateUtf8('Invalid %.CreateFrom', [self]);
end;

constructor TEccCertificate.CreateFromBase64(const base64: RawUtf8);
begin
  Create;
  if not FromBase64(base64) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromBase64', [self]);
end;

constructor TEccCertificate.CreateFromAuth(const AuthPubKey: TFileName;
  const AuthBase64, AuthSerial: RawUtf8);
begin
  Create;
  if not FromAuth(AuthPubKey, AuthBase64, AuthSerial) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromAuth', [self]);
end;

function TEccCertificate.GetAuthorityIssuer: RawUtf8;
begin
  result := EccText(fContent.Signed.AuthorityIssuer);
end;

function TEccCertificate.GetAuthoritySerial: RawUtf8;
begin
  result := EccText(fContent.Signed.AuthoritySerial);
end;

function TEccCertificate.GetIssueDate: RawUtf8;
begin
  result := EccText(fContent.Signed.IssueDate);
end;

function TEccCertificate.GetIssuer: RawUtf8;
begin
  result := EccText(fContent.Signed.Issuer);
end;

function TEccCertificate.GetSerial: RawUtf8;
begin
  result := EccText(fContent.Signed.Serial);
end;

function TEccCertificate.GetValidityEnd: RawUtf8;
begin
  result := EccText(fContent.Signed.ValidityEnd);
end;

function TEccCertificate.GetValidityStart: RawUtf8;
begin
  result := EccText(fContent.Signed.ValidityStart);
end;

function TEccCertificate.GetIsSelfSigned: boolean;
begin
  result := (self <> nil) and
            EccSelfSigned(fContent);
end;

function TEccCertificate.CheckCRC: boolean;
begin
  result := (self <> nil) and
            EccCheck(fContent);
end;

function TEccCertificate.FromBase64(const base64: RawUtf8): boolean;
var
  st: TRawByteStringStream;
begin
  if base64 = '' then
    result := false
  else
  begin
    st := TRawByteStringStream.Create(Base64ToBinSafe(base64));
    try
      result := LoadFromStream(st) and EccCheck(fContent);
    finally
      st.Free;
    end;
  end;
end;

function TEccCertificate.FromFile(const filename: TFileName): boolean;
var
  json: RawUtf8;
  fn: TFileName;
begin
  if ExtractFileExt(filename) = '' then
    fn := filename + ECCCERTIFICATEPUBLIC_FILEEXT
  else
    fn := filename;
  json := StringFromFile(fn);
  if json = '' then
    result := false
  else
    result := FromBase64(JsonDecode(json, 'Base64', nil, true));
end;

function TEccCertificate.FromAuth(const AuthPubKey: TFileName; const AuthBase64,
  AuthSerial: RawUtf8): boolean;
var
  authfilename: TFileName;
begin
  result := true;
  if FromFile(AuthPubKey) or FromBase64(AuthBase64) then
    exit;
  if AuthSerial <> '' then
  begin
    authfilename := Utf8ToString(AuthSerial);
    if EccKeyFileFind(authfilename, false) and
       FromFile(authfilename) then
      exit;
  end;
  result := false;
end;

procedure TEccCertificate.SetBase64(const base64: RawUtf8);
begin
  FromBase64(base64);
end;

function TEccCertificate.ToBase64: RawUtf8;
var
  st: TRawByteStringStream;
begin
  st := TRawByteStringStream.Create;
  try
    if SaveToStream(st) then
      result := BinToBase64(st.DataString);
  finally
    st.Free;
  end;
end;

function TEccCertificate.PublicToBase64: RawUtf8;
var
  sav: boolean;
begin
  sav := fStoreOnlyPublicKey;
  fStoreOnlyPublicKey := true;
  result := ToBase64;
  fStoreOnlyPublicKey := sav;
end;

function TEccCertificate.LoadFromStream(Stream: TStream): boolean;
begin
  result := (Stream.Read(fContent, sizeof(fContent)) = sizeof(fContent)) and
    InternalLoad(ReadStringFromStream(Stream, 524288));
end;

function TEccCertificate.SaveToStream(Stream: TStream): boolean;
begin
  result := CheckCRC and
    (Stream.Write(fContent, sizeof(fContent)) = sizeof(fContent)) and
    WriteStringToStream(Stream, InternalSave);
end;

function TEccCertificate.InternalLoad(const data: RawByteString): boolean;
begin
  result := true;
end;

function TEccCertificate.InternalSave: RawByteString;
begin
  result := '';
end;

{$ifdef ISDELPHI20062007}
  {$WARNINGS OFF} // circumvent Delphi 2007 false positive warning
{$endif}

function TEccCertificate.Encrypt(const Plain: RawByteString;
  Signature: TEccSignatureCertified; FileDateTime: TDateTime;
  const KDFSalt: RawUtf8; KDFRounds: integer; const MACSalt: RawUtf8;
  MACRounds: integer; Algo: TEciesAlgo): RawByteString;
var
  rndpriv: TEccPrivateKey;
  head: TEciesHeader;
  secret, dec, enc, content: RawByteString;
  aeskey, mackey: THash256Rec;
  c: TAesAbstractClass;
begin
  result := '';
  if Plain = '' then
    exit;
  if not CheckCRC then
    raise EECCException.CreateUtf8('%.Encrypt: no public key', [self]);
  if Algo = ecaUnknown then // use safest algorithm by default
    if IsContentCompressed(pointer(Plain), length(Plain)) then
      Algo := ecaPBKDF2_HMAC_SHA256_AES256_CFB
    else
      Algo := ecaPBKDF2_HMAC_SHA256_AES256_CFB_SYNLZ;
  if not (Algo in [ecaFIRST .. ecaLAST]) then
    raise EECCException.CreateUtf8('%.Encrypt: unsupported %', [self, ToText(Algo)^]);
  try
    head.magic := THash128(ECIES_MAGIC[0]);
    head.rec := fContent.Signed.Issuer;
    head.recid := fContent.Signed.Serial;
    head.size := length(Plain);
    head.date := NowEccDate;
    head.unixts := DateTimeToUnixTime(FileDateTime);
    content := Plain;
    if Signature.Check then
    begin
      head.sign := Signature.fContent;
      if Signature.InheritsFrom(TEccSignatureCertifiedFile) then
        with _Safe(TEccSignatureCertifiedFile(Signature).MetaData)^ do
          if (Kind = dvObject) and
             (Count > 0) then
          begin
            head.magic := THash128(ECIES_MAGIC[1]); // indicates efMetaData
            content := ToJson('', '', jsonUnquotedPropNameCompact) + #0 + content;
          end; // new format storing {metadata}+#0+plain
    end
    else
      FillcharFast(head.sign, sizeof(head.sign), 255); // Version=255=not signed
    if not ecc_make_key(head.rndpub, rndpriv) then
      raise EECCException.CreateUtf8('%.Encrypt: ecc_make_key?', [self]);
    SetLength(secret, sizeof(TEccSecretKey));
    if not ecdh_shared_secret(fContent.Signed.PublicKey, rndpriv, PEccSecretKey(secret)^) then
      raise EECCException.CreateUtf8('%.Encrypt: ecdh_shared_secret?', [self]);
    PBKDF2_HMAC_SHA256(secret, KDFSalt, KDFRounds, aeskey.b, 'salt');
    if Algo in ECIES_SYNLZ then
    begin
      dec := AlgoSynLZ.Compress(content);
      if length(dec) > length(content) then
      begin
        // SynLZ was inefficient -> just store, don't compress
        FillZero(dec);
        dec := content;
        Algo := ECIES_WITHOUTSYNLZ[Algo];
      end;
    end
    else
      dec := content;
    head.Algo := Algo;
    c := TAesFast[ECIES_AES[Algo]];
    if Algo in ECIES_AEAD then
    begin
      // encrypt e.g. with AES-GCM single pass message authentication
      case ECIES_AESSIZE[Algo] of
        128:
          enc := c.MacEncrypt(dec, aeskey.Lo, {encrypt=}true);
        256:
          enc := c.MacEncrypt(dec, aeskey.b, true);
      end;
      if length(enc) < SizeOf(TMacAndCryptData) then
        exit;
      // retrieve the GMAC directly from the raw result
      head.hmac := PMacAndCryptData(enc)^.mac;
    end
    else
    begin
      // encrypt with PKCS7 padding
      enc := c.SimpleEncrypt(
        dec, aeskey, ECIES_AESSIZE[Algo], true, true);
      // HMAC of the encrypted content
      PBKDF2_HMAC_SHA256(secret, MACSalt, MACRounds, mackey.b, 'hmac');
      HMAC_SHA256(mackey.b, enc, head.hmac);
    end;
    head.crc := crc32c(PCardinal(@head.hmac)^, @head, sizeof(head) - sizeof(head.crc));
    SetLength(result, sizeof(head) + length(enc));
    PEciesHeader(result)^ := head;
    MoveFast(pointer(enc)^, PByteArray(result)[sizeof(head)], length(enc));
  finally
    FillZero(aeskey.b);
    FillZero(mackey.b);
    FillCharFast(rndpriv, sizeof(rndpriv), 0);
    if dec <> Plain then
      FillZero(dec);
    if content <> Plain then
      FillZero(content);
    FillZero(secret);
  end;
end;

{$ifdef ISDELPHI20062007}
  {$WARNINGS ON} // circumvent Delphi 2007 false positive warning
{$endif}

function TEccCertificate.EncryptFile(const FileToCrypt, DestFile: TFileName;
  const Salt: RawUtf8; SaltRounds: integer; Algo: TEciesAlgo; IncludeSignFile:
  boolean): boolean;
var
  plain, encrypted: RawByteString;
  cert: TEccSignatureCertified;
  dest: TFileName;
  filetime: TDateTime;
begin
  plain := StringFromFile(FileToCrypt);
  if plain = '' then
    raise EECCException.CreateUtf8('File not found: [%]', [FileToCrypt]);
  if DestFile = '' then
    dest := FileToCrypt + ENCRYPTED_FILEEXT
  else
    dest := DestFile;
  filetime := FileAgeToDateTime(FileToCrypt);
  try
    if IncludeSignFile then
      cert := TEccSignatureCertifiedFile.CreateFromFile(FileToCrypt, true)
    else
      cert := nil;
    try
      encrypted := Encrypt(plain, cert, filetime, Salt, SaltRounds, 'hmac', 100, Algo);
      if encrypted = '' then
        result := false
      else
        result := FileFromString(encrypted, dest);
    finally
      cert.Free;
    end;
  finally
    FillZero(plain);
  end;
end;

function TEccCertificate.ToVariant(withBase64: boolean): variant;
begin
  result := _ObjFast([
    'Version', Version,
    'Serial', Serial,
    'Issuer', Issuer,
    'IssueDate', IssueDate,
    'ValidityStart', ValidityStart,
    'ValidityEnd', ValidityEnd,
    'AuthoritySerial', AuthoritySerial,
    'AuthorityIssuer', AuthorityIssuer,
    'IsSelfSigned', IsSelfSigned]);
  if withBase64 then
    TDocVariantData(result).AddValue('Base64', RawUtf8ToVariant(ToBase64));
end;

function TEccCertificate.ToFile(const filename: TFileName): boolean;
begin
  if CheckCRC then
    result := JsonReformatToFile(VariantSaveJson(ToVariant), filename)
  else
    result := false;
end;


{ TEccCertificateSecret }

constructor TEccCertificateSecret.CreateNew(Authority: TEccCertificateSecret;
  const IssuerText: RawUtf8; ExpirationDays: integer; StartDate: TDateTime;
  ParanoidVerify: boolean);
var
  priv: PEccPrivateKey;
  pub: PEccPublicKey;
  now: TEccDate;
  sha: TSha256;
  hash: TSha256Digest;
  temp: TEccSignature;
  retry: boolean;
begin
  Create;
  now := NowEccDate;
  with fContent.Signed do
  begin
    IssueDate := now;
    if ExpirationDays > 0 then
    begin
      if StartDate = 0 then
        ValidityStart := now
      else
        ValidityStart := EccDate(StartDate);
      ValidityEnd := ValidityStart + ExpirationDays;
    end;
    TAesPrng.Fill(TAesBlock(Serial));
    if IssuerText = '' then
      TAesPrng.Fill(TAesBlock(Issuer))
    else
      EccIssuer(IssuerText, Issuer);
    for retry := false to true do
    begin
      if not ecc_make_key(PublicKey, fPrivateKey) then
        raise EECCException.CreateUtf8('%.CreateNew: ecc_make_key?', [self]);
      if Authority = nil then
      begin
        AuthoritySerial := Serial;
        AuthorityIssuer := Issuer;
        priv := @fPrivateKey; // self-signing
        pub := @PublicKey;
      end
      else
      begin
        AuthoritySerial := Authority.fContent.Signed.Serial;
        AuthorityIssuer := Authority.fContent.Signed.Issuer;
        priv := @Authority.fPrivateKey;
        pub := @Authority.fContent.Signed.PublicKey;
        if ParanoidVerify then // check below will be on Authority keys
          if not ecdsa_sign(fPrivateKey, hash{%H-}, temp) or
             not ecdsa_verify(PublicKey, hash, temp) then
            if retry then
              raise EECCException.CreateUtf8('%.CreateNew: ParanoidVerify1?', [self])
            else
              continue;
      end;
      sha.Full(@fContent.Signed, sizeof(TEccCertificateSigned), hash);
      if not ecdsa_sign(priv^, hash, fContent.Signature) then
        raise EECCException.CreateUtf8('%.CreateNew: ecdsa_sign?', [self]);
      if not ParanoidVerify or
         ecdsa_verify(pub^, hash, fContent.Signature) then
        break
      else if retry then
        raise EECCException.CreateUtf8('%.CreateNew: ParanoidVerify2?', [self]);
    end;
  end;
  fContent.CRC := fnv32(0, @fContent, sizeof(fContent) - 4);
end;

constructor TEccCertificateSecret.CreateFromSecureBinary(const Binary:
  RawByteString; const PassWord: RawUtf8; Pbkdf2Round: integer;
  AES: TAesAbstractClass);
begin
  CreateFromSecureBinary(pointer(Binary), length(Binary), PassWord, Pbkdf2Round, AES);
end;

constructor TEccCertificateSecret.CreateFromSecureBinary(Data: pointer; Len:
  integer; const PassWord: RawUtf8; Pbkdf2Round: integer; AES: TAesAbstractClass);
begin
  Create;
  if not LoadFromSecureBinary(Data, Len, PassWord, Pbkdf2Round, AES) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromSecureBinary', [self]);
end;

constructor TEccCertificateSecret.CreateFromSecureFile(const FileName: TFileName;
  const PassWord: RawUtf8; Pbkdf2Round: integer; AES: TAesAbstractClass);
begin
  Create;
  if not LoadFromSecureFile(FileName, PassWord, Pbkdf2Round, AES) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromSecureFile("%")', [self,
      FileName]);
end;

constructor TEccCertificateSecret.CreateFromSecureFile(const FolderName:
  TFileName; const Serial, PassWord: RawUtf8; Pbkdf2Round: integer;
  AES: TAesAbstractClass);
begin
  CreateFromSecureFile(
    IncludeTrailingPathDelimiter(FolderName) + Utf8ToString(Serial),
    PassWord, Pbkdf2Round, AES);
end;

destructor TEccCertificateSecret.Destroy;
begin
  FillZero(fPrivateKey);
  inherited Destroy;
end;

function TEccCertificateSecret.InternalLoad(const data: RawByteString): boolean;
begin
  result := fStoreOnlyPublicKey or
            TAesPrng.AFUnsplit(data, fPrivateKey, sizeof(fPrivateKey));
end;

function TEccCertificateSecret.InternalSave: RawByteString;
begin
  if fStoreOnlyPublicKey then
    result := ''
  else
    result := TAesPrng.Main.AFSplit(
                fPrivateKey, sizeof(fPrivateKey), fAFSplitStripes);
end;

function TEccCertificateSecret.HasSecret: boolean;
begin
  result := (self <> nil) and
            not IsZero(THash256(fPrivateKey));
end;

const
  // header of a private key binary file
  PRIVKEY_MAGIC: array[0..15] of AnsiChar =
    'SynEccPrivatKey'#26;
  // 128-bit is enough, since it is transmitted as clear
  PRIVKEY_SALTSIZE = 16;

function TEccCertificateSecret.SaveToSecureBinary(const PassWord: RawUtf8;
  AFStripes, Pbkdf2Round: integer; AES: TAesAbstractClass; NoHeader: boolean):
  RawByteString;
var
  pksav: boolean;
  stsav, head: integer;
  st: TRawByteStringStream;
  salt, enc: RawByteString;
  aeskey: TAesKey;
  a: TAesAbstract;
  e: PAnsiChar absolute result;
begin
  result := '';
  if AES = nil then
    AES := TAesCfb;
  pksav := fStoreOnlyPublicKey;
  stsav := fAFSplitStripes;
  try
    fStoreOnlyPublicKey := false;
    fAFSplitStripes := AFStripes;
    salt := TAesPrng.Fill(PRIVKEY_SALTSIZE);
    st := TRawByteStringStream.Create;
    try
      if SaveToStream(st) then
      begin
        PBKDF2_HMAC_SHA256(PassWord, salt, Pbkdf2Round, aeskey);
        a := AES.Create(aeskey);
        try
          enc := a.EncryptPkcs7(st.DataString, true);
          // result := PRIVKEY_MAGIC+salt+enc; fails under FPC :(
          if NoHeader then
            head := 0
          else
            head := sizeof(PRIVKEY_MAGIC);
          SetLength(result, head + PRIVKEY_SALTSIZE + length(enc));
          MoveFast(PRIVKEY_MAGIC, e[0], head);
          XorBlock16(pointer(salt), @e[head], @PRIVKEY_MAGIC);
          MoveFast(pointer(enc)^, e[head + PRIVKEY_SALTSIZE], length(enc));
        finally
          a.Free;
        end;
      end;
    finally
      FillcharFast(pointer(st.DataString)^, length(st.DataString), 0);
      st.Free;
    end;
  finally
    fStoreOnlyPublicKey := pksav;
    fAFSplitStripes := stsav;
    FillZero(aeskey);
  end;
end;

function TEccCertificateSecret.SaveToSecureFileName(
  FileNumber: integer): TFileName;
var
  tmp: RawUtf8;
begin
  if self = nil then
    result := ''
  else
  begin
    if FileNumber > 0 then
      FormatUtf8('%-%', [Serial, UInt3DigitsToShort(FileNumber)], tmp)
    else
      tmp := Serial;
    result := Utf8ToString(tmp) + ECCCERTIFICATESECRET_FILEEXT;
  end;
end;

function TEccCertificateSecret.SaveToSecureFile(const PassWord: RawUtf8;
  const DestFolder: TFileName; AFStripes, Pbkdf2Round: integer;
  AES: TAesAbstractClass; NoHeader: boolean): boolean;
begin
  if (self = nil) or
     not DirectoryExists(DestFolder) then
    result := false
  else
    result := FileFromString(SaveToSecureBinary(PassWord, AFStripes,
      Pbkdf2Round, AES, NoHeader), IncludeTrailingPathDelimiter(DestFolder) +
      SaveToSecureFileName);
end;

function TEccCertificateSecret.SaveToSecureFiles(const PassWord: RawUtf8;
  const DestFolder: TFileName; DestFileCount, AFStripes, Pbkdf2Round: integer;
  AES: TAesAbstractClass; NoHeader: boolean): boolean;
var
  diff, one: RawByteString;
  head, index, pos, difflen, onechunk, onelen: integer;
  o: PAnsiChar absolute one;
  dest: TFileName;
begin
  if DestFileCount = 1 then
  begin
    result := SaveToSecureFile(
      PassWord, DestFolder, AFStripes, Pbkdf2Round, AES, NoHeader);
    exit;
  end;
  result := false;
  dest := IncludeTrailingPathDelimiter(DestFolder);
  if (self = nil) or
     (DestFileCount <= 0) or
     not DirectoryExists(dest) then
    exit;
  if DestFileCount > 255 then
    DestFileCount := 255;
  diff := SaveToSecureBinary(
    PassWord, AFStripes * DestFileCount, Pbkdf2Round, AES, true);
  difflen := length(diff);
  onechunk := difflen div DestFileCount;
  if NoHeader then
    head := 0
  else
    head := sizeof(PRIVKEY_MAGIC);
  pos := 0;
  for index := 1 to DestFileCount do
  begin
    if index < DestFileCount then
      onelen := onechunk
    else
      onelen := difflen - pos;
    SetLength(one, head + 2 + onelen);
    MoveFast(PRIVKEY_MAGIC, PByteArray(one)^[0], head);
    PByteArray(one)^[head] := index;
    PByteArray(one)^[head + 1] := DestFileCount;
    MoveFast(PByteArray(diff)[pos], PByteArray(one)^[head + 2], onelen);
    inc(pos, onelen);
    if not FileFromString(one, SaveToSecureFileName(index)) then
      exit;
  end;
  result := true;
end;

function TEccCertificateSecret.LoadFromSecureBinary(
  const Binary: RawByteString; const PassWord: RawUtf8;
  Pbkdf2Round: integer; AES: TAesAbstractClass): boolean;
begin
  result := LoadFromSecureBinary(
    pointer(Binary), length(Binary), PassWord, Pbkdf2Round, AES);
end;

function TEccCertificateSecret.LoadFromSecureBinary(Data: pointer; Len: integer;
  const PassWord: RawUtf8; Pbkdf2Round: integer; AES: TAesAbstractClass): boolean;
var
  salt, decrypted: RawByteString;
  st: TRawByteStringStream;
  aeskey: TAesKey;
  head: integer;
  a: TAesAbstract;
begin
  result := false;
  dec(Len, PRIVKEY_SALTSIZE);
  if (self = nil) or
     (Len <= sizeof(PRIVKEY_MAGIC) + sizeof(TAesBlock)) then
    exit;
  if IsEqual(THash128(PRIVKEY_MAGIC), PHash128(Data)^) then
  begin
    dec(Len, 16);
    head := 16;
  end
  else
    // was with NoHeader=true (e.g. SaveToSource)
    head := 0;
  if Len and AesBlockMod <> 0 then
    exit;
  SetString(salt, PAnsiChar(Data) + head, PRIVKEY_SALTSIZE);
  try
    XorBlock16(pointer(salt), @PRIVKEY_MAGIC);
    PBKDF2_HMAC_SHA256(PassWord, salt, Pbkdf2Round, aeskey);
    if AES = nil then
      AES := TAesCfb;
    a := AES.Create(aeskey);
    try
      decrypted := a.DecryptPkcs7Buffer(PAnsiChar(Data) + head +
        PRIVKEY_SALTSIZE, Len, true, false);
      if decrypted = '' then
        exit; // invalid content
    finally
      a.Free;
    end;
    st := TRawByteStringStream.Create(decrypted);
    try
      if LoadFromStream(st) then
        result := EccCheck(fContent) and
                  not IsZero(THash256(fPrivateKey));
    finally
      st.Free;
    end;
  finally
    FillZero(decrypted);
    FillZero(aeskey);
  end;
end;

function TEccCertificateSecret.LoadFromSecureFile(const FileName: TFileName;
  const PassWord: RawUtf8; Pbkdf2Round: integer; AES: TAesAbstractClass): boolean;
var
  FN: TFileName;
begin
  if ExtractFileExt(FileName) = '' then
    FN := FileName + ECCCERTIFICATESECRET_FILEEXT
  else
    FN := FileName;
  result := LoadFromSecureBinary(
    StringFromFile(FN), PassWord, Pbkdf2Round, AES);
end;

function TEccCertificateSecret.SaveToSource(
  const ConstName, Comment, PassWord: RawUtf8; IncludePassword: boolean;
  AFStripes, Pbkdf2Round: integer; AES: TAesAbstractClass;
  IncludeRaw: boolean): RawUtf8;
var
  data: RawByteString;
  name, suffix: RawUtf8;
begin
  result := '';
  if (self = nil) or
     (PassWord = '') then
    exit;
  data := SaveToSecureBinary(
    PassWord, AFStripes, Pbkdf2Round, AES, {NoHeader=}true);
  if data = '' then
    exit;
  if ConstName = '' then
    name := '_' + copy(Serial, 1, 24)
  else
    name := UpperCase(ConstName);
  if IncludePassword then
    suffix := FormatUtf8('  %_PASS = %;'#13#10'  %_CYPH = ''%'';'#13#10,
      [name, QuotedStr(PassWord), name,
       TSynPersistentWithPassword.ComputePassword(PassWord)]);
  if ConstName <> '' then
    suffix := FormatUtf8('  %_SERIAL = ''%'';'#13#10'%',
      [name, Serial, {%H-}suffix]);
  suffix := FormatUtf8('  %_ROUNDS = %;'#13#10'%',
    [name, Pbkdf2Round, suffix]);
  if IncludeRaw then
    suffix := FormatUtf8('  %_RAW = ''%'';'#13#10'%', [name,
      mormot.core.text.BinToHex(@fPrivateKey, sizeof(fPrivateKey)), suffix]);
  result := BinToSource(name, Comment, pointer(data), length(data), 16, suffix)
end;

function TEccCertificateSecret.SignToBase64(Data: pointer; Len: integer): RawUtf8;
begin
  if (Data = nil) or
     (Len < 0) then
    result := ''
  else
    result := SignToBase64(Sha256Digest(Data, Len));
end;

function TEccCertificateSecret.SignToBase64(const Hash: THash256): RawUtf8;
var
  sign: TEccSignatureCertified;
begin
  result := '';
  if (self = nil) or
     IsZero(Hash) then
    exit;
  sign := TEccSignatureCertified.CreateNew(self, Hash);
  try
    result := sign.ToBase64;
  finally
    sign.Free;
  end;
end;

function TEccCertificateSecret.SignFile(const FileToSign: TFileName;
  const MetaNameValuePairs: array of const): TFileName;
var
  content: RawByteString;
  sign: RawUtf8;
  doc, meta: TDocVariantData;
  sha: TSha256Digest;
begin
  content := StringFromFile(FileToSign);
  if content = '' then
    raise EECCException.CreateUtf8(
      '%.SignFile: file [%] not found', [self, FileToSign]);
  sha := Sha256Digest(pointer(content), length(content));
  sign := SignToBase64(sha);
  meta.InitObject([
    'name', ExtractFileName(FileToSign),
    'date', DateTimeToIso8601Text(FileAgeToDateTime(FileToSign))],
    JSON_OPTIONS_FAST);
  meta.AddNameValuesToObject(MetaNameValuePairs);
  doc.InitObject([
    'meta', variant(meta),
    'size', length(content),
    'md5', Md5(content),
    'sha256', Sha256DigestToString(sha),
    'sign', sign],
    JSON_OPTIONS_FAST);
  result := FileToSign + ECCCERTIFICATESIGN_FILEEXT;
  FileFromString(doc.ToJson('', '', jsonHumanReadable), result);
end;

function TEccCertificateSecret.Decrypt(const Encrypted: RawByteString;
  out Decrypted: RawByteString; Signature: PEccSignatureCertifiedContent;
  MetaData: PRawJson; FileDateTime: PDateTime; const KDFSalt: RawUtf8;
  KDFRounds: integer; const MACSalt: RawUtf8; MACRounds: integer): TEccDecrypt;
var
  head: TEciesHeader;
  features: TEciesFeatures;
  data: PAnsiChar;
  datalen, metaend: integer;
  secret, enc, dec, temp: RawByteString;
  aeskey, mackey: THash256Rec;
  hmac: THash256;
  c: TAesAbstractClass;
begin
  result := ecdCorrupted;
  datalen := length(Encrypted) - sizeof(TEciesHeader);
  if (datalen <= 0) or
     not EciesHeader(Encrypted, head) then
    exit;
  data := @PByteArray(Encrypted)[sizeof(TEciesHeader)];
  if CheckCRC and HasSecret then
  try
    if not IsEqual(head.recid, fContent.Signed.Serial) then
    begin
      result := ecdInvalidSerial;
      exit;
    end;
    SetLength(secret, sizeof(TEccSecretKey));
    if not ecdh_shared_secret(
        head.rndpub, fPrivateKey, PEccSecretKey(secret)^) then
      exit;
    result := ecdInvalidMAC;
    PBKDF2_HMAC_SHA256(secret, KDFSalt, KDFRounds, aeskey.b, 'salt');
    c := TAesFast[ECIES_AES[head.Algo]];
    if head.Algo in ECIES_AEAD then
    begin
      // decrypt e.g. with AES-GCM single pass message authentication
      case ECIES_AESSIZE[head.Algo] of
        128:
          enc := c.MacEncrypt(dec{%H-}, aeskey.Lo, {encrypt=}false);
        256:
          enc := c.MacEncrypt(dec, aeskey.b, false);
      end;
      if length(enc) < SizeOf(TMacAndCryptData) then
        // MacDecryptCheckTag() failed
        exit;
    end
    else
    begin
      // validate the HMAC signature of the encrypted content
      PBKDF2_HMAC_SHA256(secret, MACSalt, MACRounds, mackey.b, 'hmac');
      HMAC_SHA256(@mackey, data, sizeof(mackey), datalen, hmac);
      if not IsEqual(hmac, head.hmac) then
        exit;
      // decrypt the content
      SetString(enc, data, datalen);
      dec := c.SimpleEncrypt(
        enc, aeskey, ECIES_AESSIZE[head.Algo], false, true);
    end;
    if head.Algo in ECIES_SYNLZ then
      AlgoSynLZ.Decompress(pointer(dec), length(dec), Decrypted)
    else
      Decrypted := dec;
    result := ecdDecryptError;
    features := EciesFeatures(head);
    if efMetaData in features then
    begin
      if (Decrypted = '') or
         (Decrypted[1] <> '{') then
        exit;
      metaend := PosExChar(#0, Decrypted); // {metadata}+#0+plain
      if metaend = 0 then
        exit;
      if MetaData <> nil then
        MetaData^ := copy(Decrypted, 1, metaend - 1);
      temp := copy(Decrypted, metaend + 1, maxInt);
      FillZero(Decrypted); // avoid uncyphered content on heap
      Decrypted := temp;
    end;
    if cardinal(length(Decrypted)) <> head.size then
      exit;
    if FileDateTime <> nil then
      if head.unixts = 0 then
        FileDateTime^ := 0
      else
        FileDateTime^ := UnixTimeToDateTime(head.unixts);
    if (Signature <> nil) and
       EccCheck(head.sign) then
    begin
      result := ecdDecryptedWithSignature;
      Signature^ := head.sign;
    end
    else
      result := ecdDecrypted;
  finally
    FillZero(aeskey.b);
    FillZero(mackey.b);
    FillZero(secret);
    if dec <> Decrypted then
      FillZero(dec);
  end
  else
    result := ecdNoPrivateKey;
end;

function TEccCertificateSecret.DecryptFile(const FileToDecrypt,
  DestFile: TFileName; const Salt: RawUtf8; SaltRounds: integer;
  Signature: PEccSignatureCertifiedContent; MetaData: PRawJson): TEccDecrypt;
var
  content, plain: RawByteString;
  dest: TFileName;
  filetime: TDateTime;
begin
  content := StringFromFile(FileToDecrypt);
  result := ecdNoContent;
  if content <> '' then
  try
    result := ecdNoPrivateKey;
    if not CheckCRC then
      exit;
    if DestFile = '' then
      dest := GetFileNameWithoutExt(FileToDecrypt)
    else
      dest := DestFile;
    result := Decrypt(
      content, plain, Signature, MetaData, @filetime, Salt, SaltRounds);
    if result in ECC_VALIDDECRYPT then
      if not FileFromString(plain, dest, false, filetime) then
        result := ecdWriteFileError;
  finally
    FillZero(plain);
  end;
end;


{ TEccCertificateSecretSetting }

function TEccCertificateSecretSetting.CertificateSecret(
  const FolderName: TFileName): TEccCertificateSecret;
begin
  if self = nil then
    result := nil
  else if filename <> '' then
    result := TEccCertificateSecret.CreateFromSecureFile(
      filename, GetPassWordPlain, PasswordRounds)
  else if Serial = '' then
    result := nil
  else
    result := TEccCertificateSecret.CreateFromSecureFile(
      FolderName, Serial, GetPassWordPlain, PasswordRounds);
end;

constructor TEccCertificateSecretSetting.Create;
begin
  inherited Create;
  fPasswordRounds := DEFAULT_ECCROUNDS;
end;


{ TEccCertificateDecryptSetting }

constructor TEccCertificateDecryptSetting.Create;
begin
  inherited Create;
  fSalt := 'salt';
  fSaltRounds := DEFAULT_ECCROUNDS;
end;


{ TEccSignatureCertified }

constructor TEccSignatureCertified.Create;
begin
  inherited Create;
  fContent.Version := 1;
end;

constructor TEccSignatureCertified.CreateFrom(const binary:
  TEccSignatureCertifiedContent; NoException: boolean);
begin
  Create;
  if EccCheck(binary) then
    fContent := binary
  else if not NoException then
    raise EECCException.CreateUtf8(
      'Invalid %.CreateFrom', [self]);
end;

constructor TEccSignatureCertified.CreateFromBase64(const base64: RawUtf8;
  NoException: boolean);
begin
  Create;
  if not FromBase64(base64) then
    if not NoException then
      raise EECCException.CreateUtf8(
        'Invalid %.CreateFromBase64', [self]);
end;

constructor TEccSignatureCertified.CreateFromFile(const signfilename: TFileName;
  NoException: boolean);
begin
  Create;
  if not FromFile(signfilename) then
    if not NoException then
      raise EECCException.CreateUtf8(
        'Invalid %.CreateFromFile("%")', [self, signfilename]);
end;

constructor TEccSignatureCertified.CreateNew(Authority: TEccCertificateSecret;
  Data: pointer; Len: integer);
begin
  CreateNew(Authority, Sha256Digest(Data, Len));
end;

constructor TEccSignatureCertified.CreateNew(Authority: TEccCertificateSecret;
  const Hash: THash256);
begin
  Create;
  if not Authority.HasSecret then
    raise EECCException.CreateUtf8(
      '%.CreateNew: secret=0 %', [self, Authority]);
  if IsZero(Hash) then
    raise EECCException.CreateUtf8(
      '%.CreateNew(Hash=0)', [self]);
  fContent.Date := NowEccDate;
  fContent.AuthoritySerial := Authority.Content.Signed.Serial;
  fContent.AuthorityIssuer := Authority.Content.Signed.Issuer;
  if not ecdsa_sign(Authority.fPrivateKey, Hash, fContent.Signature) then
    raise EECCException.CreateUtf8('%.CreateNew: ecdsa_sign?', [self]);
end;

function TEccSignatureCertified.GetAuthorityIssuer: RawUtf8;
begin
  result := EccText(fContent.AuthorityIssuer);
end;

function TEccSignatureCertified.GetAuthoritySerial: RawUtf8;
begin
  result := EccText(fContent.AuthoritySerial);
end;

function TEccSignatureCertified.GetDate: RawUtf8;
begin
  result := EccText(fContent.Date);
end;

function TEccSignatureCertified.FromBase64(const base64: RawUtf8): boolean;
begin
  result := (self <> nil) and
    Base64ToBin(pointer(base64), @fContent, length(base64), sizeof(fContent), false) and
    EccCheck(fContent);
end;

function TEccSignatureCertified.FromFile(const signfilename: TFileName): boolean;
var
  json: RawUtf8;
begin
  if FileExists(signfilename + ECCCERTIFICATESIGN_FILEEXT) then
    json := StringFromFile(signfilename + ECCCERTIFICATESIGN_FILEEXT)
  else
    json := StringFromFile(signfilename);
  if json = '' then
    result := false
  else
    result := FromBase64(JsonDecode(json, 'sign', nil, true));
end;

function TEccSignatureCertified.ToBase64: RawUtf8;
begin
  result := BinToBase64(@fContent, sizeof(fContent));
end;

function TEccSignatureCertified.ToVariant: variant;
begin
  result := _ObjFast([
    'Version', Version,
    'Date', Date,
    'AuthoritySerial', AuthoritySerial,
    'AuthorityIssuer', AuthorityIssuer]);
end;

function TEccSignatureCertified.Check: boolean;
begin
  result := (self <> nil) and EccCheck(fContent);
end;

function TEccSignatureCertified.Verify(Authority: TEccCertificate;
  const hash: THash256): TEccValidity;
begin
  if self = nil then
    result := ecvBadParameter
  else if not Authority.CheckCRC then
    result := ecvUnknownAuthority
  else
    result := EccVerify(fContent, hash, Authority.fContent);
end;

function TEccSignatureCertified.Verify(Authority: TEccCertificate;
  Data: pointer; Len: integer): TEccValidity;
begin
  result := Verify(Authority, Sha256Digest(Data, Len));
end;

function TEccSignatureCertified.SaveToDERBinary: RawByteString;
const
  DER_SEQUENCE = $30;
  DER_INTEGER = $02;
var
  RPrefix, SPrefix: integer;
  P: PByteArray;
begin
  if not Check then
  begin
    result := '';
    exit;
  end;
  RPrefix := fContent.Signature[0] shr 7; // DER_INTEGER are two's complement
  SPrefix := fContent.Signature[ECC_BYTES] shr 7;
  SetLength(result, RPrefix + SPrefix + (ECC_BYTES * 2 + 6));
  P := pointer(result);
  P[0] := DER_SEQUENCE;
  P[1] := RPrefix + SPrefix + (ECC_BYTES * 2 + 4);
  P[2] := DER_INTEGER;
  P[3] := ECC_BYTES + RPrefix;
  P[4] := $00; // prepend 0 for negative number (if RPrefix=1)
  inc(PByte(P), 4 + RPrefix);
  MoveFast(fContent.Signature[0], P[0], ECC_BYTES);
  inc(PByte(P), ECC_BYTES);
  P[0] := DER_INTEGER;
  P[1] := ECC_BYTES + SPrefix;
  P[2] := $00;
  MoveFast(fContent.Signature[ECC_BYTES], P[2 + SPrefix], ECC_BYTES);
end;

function TEccSignatureCertified.SaveToDERFile(const FileName: TFileName): boolean;
begin
  if not Check then
    result := false
  else
    result := FileFromString(SaveToDERBinary, FileName);
end;


{ TEccSignatureCertifiedFile }

function TEccSignatureCertifiedFile.FromFile(const aFileName: TFileName): boolean;
var
  json: RawUtf8;
begin
  if SameText(ExtractFileExt(aFileName), ECCCERTIFICATESIGN_FILEEXT) then
    json := StringFromFile(aFileName)
  else
    json := StringFromFile(aFileName + ECCCERTIFICATESIGN_FILEEXT);
  result := FromFileJson(json);
end;

function TEccSignatureCertifiedFile.FromFileJson(const aFileContent: RawUtf8): boolean;
begin
  fLowLevelInfo.Clear;
  if not fLowLevelInfo.InitJson(aFileContent, JSON_OPTIONS_FAST) then
  begin
    result := false;
    exit;
  end;
  fSize := fLowLevelInfo.I['size'];
  fMetaData := fLowLevelInfo.GetValueOrEmpty('meta'); // Value[] makes GPF
  fMD5 := fLowLevelInfo.U['md5'];
  fSHA256 := fLowLevelInfo.U['sha256'];
  result := (fSize > 0) and
            (_Safe(fMetaData)^.Kind <> dvArray) and
            Md5StringToDigest(fMD5, fMd5Digest) and
            Sha256StringToDigest(fSHA256, fSha256Digest) and
            FromBase64(fLowLevelInfo.U['sign']);
end;

function TEccSignatureCertifiedFile.FromDecryptedFile(
  const aDecryptedContent: RawByteString;
  const Signature: TEccSignatureCertifiedContent;
  const MetaData: RawJson): boolean;
var
  MD5: TMd5;
  SHA256: TSha256;
begin
  result := EccCheck(Signature);
  if not result then
    exit;
  fSize := length(aDecryptedContent);
  MD5.Full(pointer(aDecryptedContent), fSize, fMd5Digest);
  fMD5 := Md5DigestToString(fMd5Digest);
  SHA256.Full(pointer(aDecryptedContent), fSize, fSha256Digest);
  fSHA256 := Sha256DigestToString(fSha256Digest);
  fMetaData := _JsonFast(MetaData);
  fContent := Signature;
  fLowLevelInfo.Clear;
  fLowLevelInfo.InitObject([
    'size', fSize,
    'md5', fMD5,
    'sha256', fSHA256,
    'sign', ToBase64,
    'meta', fMetaData]);
end;

constructor TEccSignatureCertifiedFile.CreateFromDecryptedFile(
  const aDecryptedContent: RawByteString;
  const Signature: TEccSignatureCertifiedContent;
  const MetaData: RawJson);
begin
  inherited Create;
  if not FromDecryptedFile(aDecryptedContent, Signature, MetaData) then
    raise EECCException.CreateUtf8(
      'Invalid Signature for %.CreateFromDecryptedFile', [self]);
end;


{ TEccCertificateChain }

constructor TEccCertificateChain.CreateFromJson(const json: RawUtf8);
begin
  Create;
  if not LoadFromJson(json) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromJson', [self]);
end;

constructor TEccCertificateChain.CreateFromArray(const values: TRawUtf8DynArray);
begin
  Create;
  if not LoadFromArray(values) then
    raise EECCException.CreateUtf8('Invalid %.CreateFromArray', [self]);
end;

destructor TEccCertificateChain.Destroy;
begin
  ObjArrayClear(fItems);
  inherited;
end;

function TEccCertificateChain.IsValid(cert: TEccCertificate): TEccValidity;
begin
  if (self = nil) or
     (cert = nil) then
    result := ecvBadParameter
  else
    result := IsValid(cert.Content);
end;

function TEccCertificateChain.IsValid(const content: TEccCertificateContent;
  ignoreDate: boolean): TEccValidity;
var
  auth: TEccCertificateContent;
  sha: TSha256;
  hash: TSha256Digest;
  crc: Int64;
begin
  result := ecvCorrupted;
  if not EccCheck(content) then
    exit;
  if not ignoreDate then
  begin
    result := ecvInvalidDate;
    if not EccCheckDate(content) then
      exit;
  end;
  if EccSelfSigned(content) then
    result := ecvValidSelfSigned
  else
    result := ecvValidSigned;
  if fIsValidCached then
  begin
    crc := crc64c(@content, sizeof(content));
    fSafe.Lock;
    try
      if Int64ScanExists(pointer(fIsValidCache), fIsValidCacheCount, crc) then
        exit;
    finally
      fSafe.Unlock;
    end;
  end
  else
    crc := 0;
  if result = ecvValidSelfSigned then
    auth.Signed.PublicKey := content.Signed.PublicKey
  else if not GetBySerial(content.Signed.AuthoritySerial, auth) then
  begin
    result := ecvUnknownAuthority;
    exit;
  end
  else if not EccCheckDate(auth) then
  begin
    result := ecvDeprecatedAuthority;
    exit;
  end;
  sha.Full(@content.Signed, sizeof(content.Signed), hash);
  if ecdsa_verify(auth.Signed.PublicKey, hash, content.Signature) then
  begin
    fSafe.Lock;
    try
      if fIsValidCached and
         (crc <> 0) then
        AddInt64(fIsValidCache, fIsValidCacheCount, crc);
    finally
      fSafe.Unlock;
    end;
  end
  else
    result := ecvInvalidSignature;
end;

function TEccCertificateChain.IndexBySerial(const Serial: TEccCertificateID): integer;
var
  ser: THash128Rec absolute Serial;
begin
  if (self <> nil) and
     ((ser.Lo <> 0) or
      (ser.Hi <> 0)) then
  begin
    for result := 0 to length(fItems) - 1 do
      with PHash128Rec(@fItems[result].Signed.Serial)^ do
      {$ifdef CPU64}
        if (ser.Lo = Lo) and
           (ser.Hi = Hi) then
      {$else}
        if (ser.i0 = i0) and
           (ser.i1 = i1) and
           (ser.i2 = i2) and
           (ser.i3 = i3) then
      {$endif}
          exit;
  end;
  result := -1;
end;

function TEccCertificateChain.GetBySerial(const Serial: TEccCertificateID):
  TEccCertificate;
var
  i: integer;
begin
  i := IndexBySerial(Serial);
  if i < 0 then
    result := nil
  else
    result := fItems[i];
end;

function TEccCertificateChain.GetBySerial(const Serial: RawUtf8): TEccCertificate;
var
  id: TEccCertificateID;
begin
  if EccID(Serial, id) then
    result := GetBySerial(id)
  else
    result := nil;
end;

function TEccCertificateChain.GetBySerial(const Serial: TEccCertificateID; out
  Content: TEccCertificateContent): boolean;
var
  cert: TEccCertificate;
begin
  fSafe.Lock;
  try
    cert := GetBySerial(Serial);
    if cert <> nil then
    begin
      Content := cert.Content;
      result := true;
    end
    else
      result := false;
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.GetBySerial(const Serial: TEccCertificateID; out
  PublicKey: TEccPublicKey): boolean;
var
  cert: TEccCertificate;
begin
  fSafe.Lock;
  try
    cert := GetBySerial(Serial);
    if cert <> nil then
    begin
      PublicKey := cert.Content.Signed.PublicKey;
      result := true;
    end
    else
      result := false;
  finally
    fSafe.UnLock;
  end;
end;

procedure TEccCertificateChain.SetIsValidCached(const Value: boolean);
begin
  if fIsValidCached = Value then
    exit;
  fSafe.Lock;
  try
    fIsValidCached := Value;
    if not Value then
    begin
      fIsValidCache := nil;
      fIsValidCacheCount := 0;
    end;
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.InternalAdd(cert: TEccCertificate; expected:
  TEccValidity): integer;
begin
  result := -1;
  if (self = nil) or
     (cert = nil) or
     (IsValid(cert.fContent, true) <> expected) then
    exit;
  fSafe.Lock;
  try
    if IndexBySerial(cert.Signed.Serial) < 0 then
      result := ObjArrayAdd(fItems, cert);
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.Add(cert: TEccCertificate): integer;
begin
  result := InternalAdd(cert, ecvValidSigned);
end;

function TEccCertificateChain.AddSelfSigned(cert: TEccCertificate): integer;
begin
  result := InternalAdd(cert, ecvValidSelfSigned);
end;

procedure TEccCertificateChain.Clear;
begin
  fSafe.Lock;
  try
    ObjArrayClear(fItems);
    fIsValidCacheCount := 0;
    fIsValidCache := nil;
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.GetCount: integer;
begin
  if self = nil then
    result := 0
  else
    result := length(fItems);
end;

function TEccCertificateChain.IsAuthorized(sign: TEccSignatureCertified): boolean;
begin
  if (self <> nil) and
     (sign <> nil) then
    result := IsAuthorized(sign.Content)
  else
    result := false;
end;

function TEccCertificateChain.IsAuthorized(const sign:
  TEccSignatureCertifiedContent): boolean;
var
  content: TEccCertificateContent;
begin
  result := GetBySerial(sign.AuthoritySerial, content) and
            IsEqual(content.Signed.AuthorityIssuer, sign.AuthorityIssuer);
end;

function TEccCertificateChain.IsAuthorized(const base64sign: RawUtf8): boolean;
var
  sign: TEccSignatureCertifiedContent;
begin
  if EccSign(base64sign, sign) then
    result := IsAuthorized(sign)
  else
    result := false;
end;

function TEccCertificateChain.IsSigned(sign: TEccSignatureCertified;
  Data: pointer; Len: integer): TEccValidity;
var
  hash: TSha256Digest;
begin
  if (self <> nil) and
     (sign <> nil) and
     (Data <> nil) and
     (Len > 0) then
  begin
    hash := Sha256Digest(Data, Len);
    if sign.InheritsFrom(TEccSignatureCertifiedFile) then
      with TEccSignatureCertifiedFile(sign) do
        if (Size <> Len) or
           not IsEqual(hash, Sha256Digest) or
           not IsEqual(Md5Buf(Data^, Len), Md5Digest) then
        begin
          result := ecvCorrupted;
          exit;
        end;
    result := IsSigned(sign.Content, hash);
  end
  else
    result := ecvBadParameter;
end;

function TEccCertificateChain.IsSigned(sign: TEccSignatureCertifiedFile): TEccValidity;
begin
  if (self <> nil) and
     (sign <> nil) then
    result := IsSigned(sign.Content, sign.Sha256Digest)
  else
    result := ecvBadParameter;
end;

function TEccCertificateChain.IsSigned(sign: TEccSignatureCertified;
  const hash: THash256): TEccValidity;
begin
  if (self <> nil) and
     (sign <> nil) then
    result := IsSigned(sign.Content, hash)
  else
    result := ecvBadParameter;
end;

function TEccCertificateChain.IsSigned(const sign: TEccSignatureCertifiedContent;
  Data: pointer; Len: integer): TEccValidity;
begin
  if (Data = nil) or
     (Len <= 0) then
    result := ecvBadParameter
  else
    result := IsSigned(sign, Sha256Digest(Data, Len));
end;

function TEccCertificateChain.IsSigned(const base64sign: RawUtf8;
  const hash: THash256): TEccValidity;
var
  sign: TEccSignatureCertifiedContent;
begin
  if EccSign(base64sign, sign) then
    result := IsSigned(sign, hash)
  else
    result := ecvBadParameter;
end;

function TEccCertificateChain.IsSigned(const base64sign: RawUtf8;
  Data: pointer; Len: integer): TEccValidity;
var
  sign: TEccSignatureCertifiedContent;
begin
  if EccSign(base64sign, sign) then
    result := IsSigned(sign, Data, Len)
  else
    result := ecvBadParameter;
end;

function TEccCertificateChain.IsSigned(const sign: TEccSignatureCertifiedContent;
  const hash: THash256): TEccValidity;
var
  auth: TEccCertificateContent;
begin
  if self = nil then
    result := ecvBadParameter
  else if not GetBySerial(sign.AuthoritySerial, auth) then
    result := ecvUnknownAuthority
  else
    result := EccVerify(sign, hash, auth);
end;

function TEccCertificateChain.SaveToJson: RawUtf8;
begin
  result := JsonEncodeArrayUtf8(SaveToArray);
end;

function TEccCertificateChain.SaveToArray: TRawUtf8DynArray;
var
  i: PtrInt;
begin
  fSafe.Lock;
  try
    SetLength(result{%H-}, length(fItems));
    for i := 0 to high(result) do
      result[i] := fItems[i].PublicToBase64;
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.LoadFromJson(const json: RawUtf8): boolean;
var
  values: TRawUtf8DynArray;
  tmp: TSynTempBuffer; // private copy
begin
  tmp.Init(json);
  try
    result :=
      (DynArrayLoadJson(values, tmp.buf, TypeInfo(TRawUtf8DynArray)) <> nil) and
      LoadFromArray(values);
  finally
    tmp.Done;
  end;
end;

function TEccCertificateChain.LoadFromArray(const values: TRawUtf8DynArray): boolean;
var
  i: PtrInt;
begin
  result := false;
  if self = nil then
    exit;
  fSafe.Lock;
  try
    Clear;
    SetLength(fItems, length(values));
    for i := 0 to high(values) do
    begin
      fItems[i] := TEccCertificate.Create;
      if not fItems[i].FromBase64(values[i]) then
      begin
        ObjArrayClear(fItems);
        exit;
      end;
    end;
  finally
    fSafe.UnLock;
  end;
  result := true;
end;

function TEccCertificateChain.ValidateItems: TEccCertificateObjArray;
var
  i: PtrInt;
begin
  result := nil;
  if self = nil then
    exit;
  fSafe.Lock;
  try
    for i := 0 to high(fItems) do
      if not (IsValid(fItems[i]) in ECC_VALIDSIGN) then
        ObjArrayAdd(result, fItems[i]);
  finally
    fSafe.UnLock;
  end;
end;

constructor TEccCertificateChain.CreateFromFile(const jsonfile: TFileName);
begin
  Create;
  if not LoadFromFile(jsonfile) then
    raise EECCException.CreateUtf8(
      'Invalid %.CreateFromFile("%")', [self, jsonfile]);
end;

constructor TEccCertificateChain.CreateFromFiles(const files: array of TFileName);
var
  i: PtrInt;
  auth: TEccCertificate;
begin
  Create;
  for i := 0 to high(files) do
  begin
    auth := TEccCertificate.Create;
    try
      if auth.FromFile(files[i]) then
      begin
        ObjArrayAdd(fItems, auth);
        auth := nil;
      end
      else
        raise EECCException.CreateUtf8(
          '%.CreateFromFiles: invalid file [%]', [self, files[i]]);
    finally
      auth.Free;
    end;
  end;
end;

function TEccCertificateChain.SaveToFileVariant: variant;
var
  pub64, items: TDocVariantData;
  i, n: PtrInt;
begin
  fSafe.Lock;
  try
    n := length(fItems);
    pub64.InitFast(n, dvArray);
    items.InitFast(n, dvArray);
    for i := 0 to n - 1 do
    begin
      pub64.AddItemText(fItems[i].PublicToBase64);
      items.AddItem(fItems[i].ToVariant(false));
    end;
    result := _ObjFast([
      'PublicBase64', variant(pub64),
      'Items', variant(items)]);
  finally
    fSafe.UnLock;
  end;
end;

function TEccCertificateChain.SaveToFileContent: RawUtf8;
begin
  VariantSaveJson(SaveToFileVariant, twJsonEscape, result{%H-});
end;

function TEccCertificateChain.LoadFromFileContent(
  const cajsoncontent: RawUtf8): boolean;
var
  doc: TDocVariantData;
  values: TRawUtf8DynArray;
begin
  result := false;
  if doc.InitJson(cajsoncontent, JSON_OPTIONS_FAST) then
  begin
    doc.GetAsDocVariantSafe('PublicBase64')^.ToRawUtf8DynArray(values);
    result := LoadFromArray(values);
  end;
end;

function GetChainFileName(const jsonfile: TFileName): TFileName;
begin
  if ExtractFileExt(jsonfile) = '' then
    result := jsonfile + ECCCERTIFICATES_FILEEXT
  else
    result := jsonfile;
end;

function TEccCertificateChain.SaveToFile(const jsonfile: TFileName): boolean;
var
  json: RawUtf8;
begin
  if (Count = 0) or
     (jsonfile = '') then
    result := false
  else
  begin
    json := SaveToFileContent;
    result := JsonBufferReformatToFile(pointer(json), GetChainFileName(jsonfile));
  end;
end;

function TEccCertificateChain.LoadFromFile(const jsonfile: TFileName): boolean;
var
  json: RawUtf8;
  fn: TFileName;
begin
  fn := GetChainFileName(jsonfile);
  json := StringFromFile(fn);
  if json = '' then
    json := StringFromFile(EccKeyFileFolder + fn);
  if json = '' then
    result := false
  else
    result := LoadFromFileContent(json);
end;



{ ***************** IProtocol Implemented using Public Key Cryptography }

function ToText(algo: TEcdheAuth): PShortString;
begin
  result := GetEnumName(TypeInfo(TEcdheAuth), ord(algo));
end;

function ToText(algo: TEcdheKdf): PShortString;
begin
  result := GetEnumName(TypeInfo(TEcdheKdf), ord(algo));
end;

function ToText(algo: TEcdheEF): PShortString;
begin
  result := GetEnumName(TypeInfo(TEcdheEF), ord(algo));
end;

function ToText(algo: TEcdheMac): PShortString;
begin
  result := GetEnumName(TypeInfo(TEcdheMac), ord(algo));
end;


{ TEcdheProtocol }

constructor TEcdheProtocol.Create(aAuth: TEcdheAuth; aPKI: TEccCertificateChain;
  aPrivate: TEccCertificateSecret; aEF: TEcdheEF);
var
  res: TEccValidity;
begin
  if (aPKI <> nil) and
     (aPrivate <> nil) then
  begin
    res := aPKI.IsValid(aPrivate);
    if not (res in ECC_VALIDSIGN) then
      raise EECCException.CreateUtf8('%.Create failed: aPKI.IsValid(%)=%',
        [self, aPrivate.Serial, ToText(res)^]);
  end;
  inherited Create;
  fAlgo.auth := aAuth;
  fAlgo.ef := aEF;
  fAlgo.mac := ECDHEPROT_EF2MAC[aEF];
  fPKI := aPKI;
  fPrivate := aPrivate;
  fEFSalt := 'ecdhesalt';
  fMacSalt := 'ecdhemac';
end;

constructor TEcdheProtocol.CreateFrom(aAnother: TEcdheProtocol);
begin
  Create(aAnother.fAlgo.auth, aAnother.fPKI, aAnother.fPrivate);
  fAlgo := aAnother.fAlgo; // may have been customized via properties
  fEFSalt := aAnother.fEFSalt;
  fMacSalt := aAnother.fMacSalt;
end;

var
  _FromKeySetCA: TEccCertificateChain;
  _FromKeySetCARefCount: integer;

destructor TEcdheProtocol.Destroy;
begin
  if fAes[true] <> fAes[false] then
    fAes[true].Free; // TAesAbstract.CloneEncryptDecrypt may have set the same
  fAes[false].Free;
  FillZero(fkM[false].b);
  FillZero(fkM[true].b);
  if fPKI <> nil then
    if ownPKI in fOwned then
      fPKI.Free
    else if (fPKI = _FromKeySetCA) and
            (_FromKeySetCARefCount > 0) then
      dec(_FromKeySetCARefCount);
  if ownPrivate in fOwned then
    fPrivate.Free;
  inherited Destroy;
end;

class procedure TEcdheProtocol.FromKeySetCA(aPKI: TEccCertificateChain);
begin
  if _FromKeySetCA <> nil then
    if _FromKeySetCARefCount > 0 then
      raise EECCException.CreateUtf8(
        '%.FromKeySetCA: % is still used by % instance(s)',
        [self, _FromKeySetCA, _FromKeySetCARefCount])
    else
      _FromKeySetCA.Free;
  _FromKeySetCA := aPKI;
end;

class function TEcdheProtocol.FromKey(const aKey: RawUtf8;
  aServer: boolean): TEcdheProtocol;
const
  CL: array[boolean] of TEcdheProtocolClass = (
    TEcdheProtocolServer, TEcdheProtocolClient);
var
  sw: TSynNameValue;
  pw, c: RawUtf8;
  fn: TFileName;
  algo: TEcdheAlgo;
  ca: TEccCertificateChain;
  chain: TRawUtf8DynArray;
  priv: TEccCertificateSecret;
  i, pr: integer;
begin
  result := nil;
  if not IdemPChar(pointer(aKey), 'A=') then
    exit;
  // a=mutual;k=hmacsha256;e=aescrc128;m=duringef;p=34a2;pw=password;pr=60000;ca=..
  sw.InitFromCsv(pointer(aKey), '=', ';');
  if not sw.ValueEnum('a', TypeInfo(TEcdheAuth), algo.auth) then
    exit; // mandatory parameter
  sw.ValueEnum('k', TypeInfo(TEcdheKdf), algo.kdf);
  sw.ValueEnum('e', TypeInfo(TEcdheEF), algo.ef);
  sw.ValueEnum('m', TypeInfo(TEcdheEF), algo.mac);
  // compute ca: TEccCertificateChain
  ca := nil;
  c := sw.Str['ca'];
  if c <> '' then
  begin
    ca := TEccCertificateChain.Create;
    fn := Utf8ToString(c);
    if not ca.LoadFromFile(fn) then
    begin
      CsvToRawUtf8DynArray(c, ',', '', chain);
      for i := 0 to high(chain) do
        chain[i] := UnQuoteSqlString(chain[i]);
      if ca.LoadFromArray(chain) then
        ca.IsValidCached := true
      else // for faster Clone process
        FreeAndnil(ca);
    end;
  end;
  if (ca = nil) and
     (_FromKeySetCA <> nil) then
  begin
    ca := _FromKeySetCA;
    inc(_FromKeySetCARefCount);
  end;
  // compute priv: TEccCertificateSecret
  priv := nil;
  fn := Utf8ToString(sw.Str['p']);
  pw := sw.Str['pw'];
  pr := sw.ValueInt('pr', 60000); // DEFAULT_ECCROUNDS may change
  if (fn <> '') and
     (pw <> '') and
     EccKeyFileFind(fn, true) then
    priv := TEccCertificateSecret.CreateFromSecureFile(fn, pw, pr);
  result := CL[aServer].Create(algo.auth, ca, priv);
  result.KDF := algo.kdf;
  result.EF := algo.ef;
  result.MAC := algo.mac;
  if (ca <> nil) and
     (ca <> _FromKeySetCA) then
    include(result.fOwned, ownPKI);
  if priv <> nil then
    include(result.fOwned, ownPrivate);
end;

class function TEcdheProtocol.FromKeyCompute(
  const privkey, privpassword: RawUtf8; privrounds: integer;
  const pki: RawUtf8; auth: TEcdheAuth; kdf: TEcdheKdf; ef: TEcdheEF;
  mac: TEcdheMac; customkey: cardinal): RawUtf8;
begin
  FormatUtf8('a=%', [ord(auth)], result);
  if kdf <> low(kdf) then
    result := result + ';k=' + TrimLeftLowerCaseShort(ToText(kdf));
  if ef <> low(ef) then
    result := result + ';e=' + TrimLeftLowerCaseShort(ToText(ef));
  if mac <> low(mac) then
    result := result + ';m=' + TrimLeftLowerCaseShort(ToText(mac));
  result := lowercase(result);
  if pki <> '' then
    result := result + ';ca=' + pki;
  if privkey <> '' then
  begin
    result := FormatUtf8('%;p=%;pw=%', [result, privkey, privpassword]);
    if privrounds <> 60000 then
      // DEFAULT_ECCROUNDS may change
      result := FormatUtf8('%;pr=%', [result, privrounds]);
  end;
  result := TSynPersistentWithPassword.ComputePassword(result, customkey);
end;

const
  ED: array[boolean] of string[7] = (
    'Decrypt', 'Encrypt');

procedure TEcdheProtocol.SetKey(aEncrypt: boolean);
begin
  if fAes[aEncrypt] = nil then
    raise EECCException.CreateUtf8(
      '%.% with no handshake', [self, ED[aEncrypt]]);
  fAes[aEncrypt].IV := fkM[aEncrypt].Lo; // kM is a CTR -> IV unicity
  if fAlgo.mac = macDuringEF then
    if not fAes[aEncrypt].MacSetNonce(aEncrypt, fkM[aEncrypt].b) then
      raise EECCException.CreateUtf8(
        '%.%: macDuringEF not available in %/%',
        [self, ED[aEncrypt], ToText(fAlgo.ef)^, fAes[aEncrypt]]);
end;

procedure TEcdheProtocol.ComputeMAC(aEncrypt: boolean;
  aEncrypted: pointer; aLen: integer; out aMAC: THash256Rec);
var
  i: PtrInt;
  c: cardinal;
begin
  // retrieve or compute the MAC
  case fAlgo.mac of
    macDuringEF:
      if aEncrypt and
         not fAes[aEncrypt].MacEncryptGetTag(aMAC.b) then
        // should have been computed during Encryption process
        raise EECCException.CreateUtf8('%.%: macDuringEF not available in %/%',
          [self, ED[aEncrypt], ToText(fAlgo.ef)^, fAes[aEncrypt]]);
    macHmacCrc256c:
      HMAC_CRC256C(@fkM[aEncrypt], aEncrypted, sizeof(THash256), aLen, aMAC.b);
    macHmacSha256:
      HMAC_SHA256(@fkM[aEncrypt], aEncrypted, sizeof(THash256), aLen, aMAC.b);
    macHmacCrc32c:
      begin
        c := HMAC_CRC32C(@fkM[aEncrypt], aEncrypted, sizeof(THash256), aLen);
        for i := 0 to 7 do
          aMAC.c[i] := c; // naive 256-bit diffusion
      end;
    macXxHash32:
      begin
        c := xxHash32(fkM[aEncrypt].i0, aEncrypted, aLen);
        for i := 0 to 7 do
          aMAC.c[i] := c; // naive 256-bit diffusion
      end;
    macNone:
      crc256c(@fkM[aEncrypt], sizeof(THash256), aMAC.b); // replay attack only
  else
    raise EECCException.CreateUtf8(
      '%.%: ComputeMAC %?', [self, ED[aEncrypt], ToText(fAlgo.mac)^]);
  end;
  // always increase sequence number against replay attacks
  with fkM[aEncrypt] do
    for i := 0 to 3 do
    begin
      inc(q[i]);
      if q[i] <> 0 then
        break;
    end;
end;

type TAesHook = class(TAesAbstract);

procedure TEcdheProtocol.Encrypt(const aPlain: RawByteString;
  out aEncrypted: RawByteString);
var
  len: integer;
begin
  fSafe.Lock;
  try
    SetKey({encrypt=}true);
    len := fAes[true].EncryptPkcs7Length(length(aPlain), false);
    SetString(aEncrypted, nil, len + sizeof(THash256)); // append a trailing MAC
    // encrypt the input
    fAes[true].EncryptPkcs7Buffer(
      Pointer(aPlain), pointer(aEncrypted), length(aPlain), len, false);
    // compute and store the MAC
    ComputeMac({encrypt=}true, pointer(aEncrypted), len,
      PHash256Rec(@PByteArray(aEncrypted)[len])^);
  finally
    fSafe.UnLock;
  end;
end;

function TEcdheProtocol.Decrypt(const aEncrypted: RawByteString;
  out aPlain: RawByteString): TProtocolResult;
var
  P: PAnsiChar absolute aEncrypted;
  len, i: PtrInt;
  mac: THash256Rec;
begin
  result := sprInvalidMAC;
  len := length(aEncrypted) - sizeof(THash256); // there is a trailing MAC
  if len <= 0 then
    exit;
  fSafe.Lock;
  try
    SetKey({encrypt=}false);
    // decrypt the input
    aPlain := fAes[false].DecryptPkcs7Buffer(P, len, false, false);
    if aPlain = '' then
    begin
      with fkM[false] do
        for i := 0 to 3 do
        begin
          inc(q[i]); // don't compute MAC, but increase sequence
          if q[i] <> 0 then
            break;
        end;
      exit;
    end;
    // validate with MAC stored after the input
    ComputeMac({encrypt=}false, P, len, mac); // also increase the CTR
    if fAlgo.mac = macDuringEF then
    begin
      // AES-GCM requires to call a specific decryption method
      if fAes[false].MacDecryptCheckTag(PHash256(P + len)^) then
        result := sprSuccess
    end
    else if IsEqual(mac.b, PHash256(P + len)^) then
      result := sprSuccess;
  finally
    fSafe.Unlock;
  end;
end;

function TEcdheProtocol.CheckError(const aEncrypted: RawByteString): TProtocolResult;
begin
  if fAlgo.mac <> macDuringEF then
  begin
    result := sprUnsupported;
    exit;
  end;
  fSafe.Lock;
  try
    SetKey({encrypt=}false);
    if fAes[false].MacCheckError(pointer(aEncrypted), length(aEncrypted)) then
      result := sprSuccess
    else
      result := sprInvalidMAC;
  finally
    fSafe.Unlock;
  end;
end;

const
  /// how TEcdheProtocol.SharedSecret initialize the AES engines
  // - if you link mormot.core.openssl.pas, CTR and GCM will use its version
  ECDHEPROT_EF2AES: array[TEcdheEF] of TAesMode = (
  // efAesCrc  efAesCfb  efAesOfb efAesCtr efAesCbc
    mCfbCrc, mCfb, mOfb, mCtrNist, mCbc, // 128-bit
    mCfbCrc, mCfb, mOfb, mCtrNist, mCbc, // 256-bit
  // cfAesGcm   cfAesCtc
    mGcm, mGcm, mCtrCrc, mCtrCrc);

procedure TEcdheProtocol.SharedSecret(sA, sB: PHash256);
var
  secret: THash256;

  procedure ComputeSecret(const salt: RawByteString);
  var
    hmac: THMAC_SHA256;
  begin
    hmac.Init(pointer(salt), length(salt));
    if fAlgo.auth <> authServer then
      hmac.Update(sA^);
    if fAlgo.auth <> authClient then
      hmac.Update(sB^);
    hmac.Update(fRndA);
    hmac.Update(fRndB);
    hmac.Done(secret);
  end;

begin
  if fAes[false] <> nil then
    raise EECCException.CreateUtf8('%.SharedSecret already called', [self]);
  if fAlgo.kdf <> kdfHmacSha256 then
    raise EECCException.CreateUtf8('%.SharedSecret %?', [self, ToText(fAlgo.kdf)^]);
  try
    ComputeSecret(fEFSalt);
    fAes[false] := TAesFast[ECDHEPROT_EF2AES[fAlgo.ef]].Create(
      secret, ECDHEPROT_EF2BITS[fAlgo.ef]);
    fAes[true] := fAes[false].CloneEncryptDecrypt;
    ComputeSecret(fMacSalt);
    fkM[false].b := secret; // first 128-bit also used as AES IV
    fkM[true].b := secret;
  finally
    FillZero(secret);
  end;
end;

function TEcdheProtocol.Verify(frame: PByteArray; len: integer;
  const QC: TEccCertificateContent; out res: TProtocolResult): boolean;
var
  hash: TSha256Digest;
  sha: TSha256;
begin
  result := false;
  res := sprInvalidCertificate;
  if fPKI <> nil then
  begin
    fCertificateValidity := fPKI.IsValid(QC);
    if not (fCertificateValidity in ECC_VALIDSIGN) then
      exit;
  end
  else if not EccCheck(QC) then
    exit;
  dec(len, sizeof(TEccSignature)); // Sign at the latest position
  sha.Full(frame, len, hash);
  res := sprInvalidSignature;
  if not ecdsa_verify(QC.Signed.PublicKey, hash, PEccSignature(@frame[len])^) then
    exit;
  res := sprSuccess;
  result := true;
end;

procedure TEcdheProtocol.sign(frame: PByteArray; len: integer;
  out QC: TEccCertificateContent);
var
  hash: TSha256Digest;
  sha: TSha256;
begin
  QC := fPrivate.fContent;
  dec(len, sizeof(TEccSignature)); // Sign at the latest position
  sha.Full(frame, len, hash);
  if not ecdsa_sign(fPrivate.fPrivateKey, hash, PEccSignature(@frame[len])^) then
    raise EECCException.CreateUtf8('%.Sign: ecdsa_sign?', [self]);
end;

function TEcdheProtocol.Clone: IProtocol;
begin
  result := TEcdheProtocolClass(ClassType).CreateFrom(self);
end;


{ TEcdheProtocolClient }

constructor TEcdheProtocolClient.Create(aAuth: TEcdheAuth;
  aPKI: TEccCertificateChain; aPrivate: TEccCertificateSecret; aEF: TEcdheEF);
begin
  if (aAuth <> authServer) and
     not aPrivate.CheckCRC then
    raise EECCException.CreateUtf8(
      '%.Create: need valid Private Key for %', [self, ToText(aAuth)^])
  else
    inherited;
end;

procedure TEcdheProtocolClient.ComputeHandshake(out aClient: TEcdheFrameClient);
begin
  if fAes[false] <> nil then
    raise EECCException.CreateUtf8(
      '%.ComputeHandshake already called', [self]);
  FillCharFast(aClient, sizeof(aClient), 0);
  aClient.algo := fAlgo;
  TAesPrng.Main.FillRandom(fRndA);
  aClient.RndA := fRndA;
  if fAlgo.auth <> authClient then
    if not ecc_make_key(aClient.QE, fdE) then
      raise EECCException.CreateUtf8(
        '%.ComputeHandshake: ecc_make_key?', [self]);
  if fAlgo.auth <> authServer then
    sign(@aClient, sizeof(aClient), aClient.QCA);
end;

function TEcdheProtocolClient.ValidateHandshake(const aServer: TEcdheFrameServer):
  TProtocolResult;
var
  sA, sB: THash256;
begin
  result := sprUnexpectedAlgorithm;
  if cardinal(aServer.algo) <> cardinal(fAlgo) then
    exit;
  result := sprBadRequest;
  if IsZero(fRndA) or
     not IsEqual(aServer.RndA, fRndA) or
     IsZero(aServer.RndB) or
     IsEqual(aServer.RndA, aServer.RndB) then
    exit;
  fRndB := aServer.RndB;
  if fAlgo.auth <> authClient then
    if not Verify(@aServer, sizeof(aServer), aServer.QCB, result) then
      exit;
  try
    result := sprInvalidEphemeralKey;
    if fAlgo.auth <> authServer then
      if not ecdh_shared_secret(aServer.QF, fPrivate.fPrivateKey, sA) then
        exit;
    result := sprInvalidPublicKey;
    if fAlgo.auth <> authClient then
      if not ecdh_shared_secret(aServer.QCB.Signed.PublicKey, fdE, sB) then
        exit;
    SharedSecret(@sA, @sB);
  finally
    FillZero(sA);
    FillZero(sB);
    FillZero(fdE);
  end;
  result := sprSuccess;
end;

function TEcdheProtocolClient.ProcessHandshake(const MsgIn: RawUtf8;
  out MsgOut: RawUtf8): TProtocolResult;
var
  out1: TEcdheFrameClient;
  in2: TEcdheFrameServer;
begin
  if MsgIn = '' then
  begin
    ComputeHandshake(out1);
    MsgOut := BinToBase64(@out1, SizeOf(out1));
    result := sprSuccess;
  end
  else if Base64ToBin(Pointer(MsgIn), @in2, length(MsgIn), sizeof(in2), false) then
    result := ValidateHandshake(in2)
  else
    result := sprBadRequest;
end;


{ TEcdheProtocolServer }

constructor TEcdheProtocolServer.Create(aAuth: TEcdheAuth; aPKI: TEccCertificateChain;
  aPrivate: TEccCertificateSecret; aEF: TEcdheEF);
begin
  if (aAuth <> authClient) and
     not aPrivate.CheckCRC then
    raise EECCException.CreateUtf8(
      '%.Create: need valid Private Key for %', [self, ToText(aAuth)^]);
  inherited;
  include(fAuthorized, aAuth); // conservative default
end;

constructor TEcdheProtocolServer.CreateFrom(aAnother: TEcdheProtocol);
begin
  inherited CreateFrom(aAnother);
  fAuthorized := (aAnother as TEcdheProtocolServer).fAuthorized;
end;

function TEcdheProtocolServer.ComputeHandshake(const aClient: TEcdheFrameClient;
  out aServer: TEcdheFrameServer): TProtocolResult;
var
  dF: TEccPrivateKey;
  sA, sB: THash256;
begin
  result := sprUnexpectedAlgorithm;
  if cardinal(aClient.algo) <> cardinal(fAlgo) then
  begin
    if not (aClient.algo.auth in fAuthorized) or
       (aClient.algo.kdf <> fAlgo.kdf) or
       (aClient.algo.ef <> fAlgo.ef) or
       (aClient.algo.mac <> fAlgo.mac) then
      exit;
    if (aClient.algo.auth <> authClient) and
       not fPrivate.CheckCRC then
      exit;
    fAlgo.auth := aClient.algo.auth; // client forced another mode
  end;
  result := sprBadRequest;
  if IsZero(aClient.RndA) then
    exit;
  fRndA := aClient.RndA;
  if fAlgo.auth <> authServer then
    if not Verify(@aClient, sizeof(aClient), aClient.QCA, result) then
      exit;
  FillCharFast(aServer, sizeof(aServer), 0);
  aServer.algo := fAlgo;
  aServer.RndA := fRndA;
  TAesPrng.Main.FillRandom(fRndB);
  aServer.RndB := fRndB;
  if fAlgo.auth <> authServer then
    if not ecc_make_key(aServer.QF, dF) then
      raise EECCException.CreateUtf8(
        '%.ComputeHandshake: ecc_make_key?', [self]);
  try
    result := sprInvalidPublicKey;
    if fAlgo.auth <> authServer then
      if not ecdh_shared_secret(aClient.QCA.Signed.PublicKey, dF, sA) then
        exit;
    result := sprInvalidEphemeralKey;
    if fAlgo.auth <> authClient then
      if not ecdh_shared_secret(aClient.QE, fPrivate.fPrivateKey, sB) then
        exit;
    SharedSecret(@sA, @sB);
  finally
    FillZero(sA);
    FillZero(sB);
    FillZero(dF);
  end;
  if fAlgo.auth <> authClient then
    sign(@aServer, sizeof(aServer), aServer.QCB);
  result := sprSuccess;
end;

function TEcdheProtocolServer.ProcessHandshake(const MsgIn: RawUtf8;
  out MsgOut: RawUtf8): TProtocolResult;
var
  in1: TEcdheFrameClient;
  out1: TEcdheFrameServer;
begin
  if Base64ToBin(Pointer(MsgIn), @in1, length(MsgIn), sizeof(in1), false) then
  begin
    result := ComputeHandshake(in1, out1);
    MsgOut := BinToBase64(@out1, SizeOf(out1));
  end
  else
    result := sprBadRequest;
end;


initialization
  {$ifndef HASDYNARRAYTYPE}
  Rtti.RegisterObjArray(TypeInfo(TEccCertificateObjArray), TEccCertificate);
  {$endif HASDYNARRAYTYPE}
  // binary headers should be consistent on all platforms/compilers
  assert(sizeof(TEciesHeader) = 228);
  assert(sizeof(TEcdheFrameClient) = 290);
  assert(sizeof(TEcdheFrameServer) = 306);

end.

