/// Framework Core Low-Level Generics Collection Process
// - this unit is a part of the Open Source Synopse mORMot framework 2,
// licensed under a MPL/GPL/LGPL three license - see LICENSE.md
unit mormot.core.collections;

{
  *****************************************************************************

   Generics Collections as used by all framework units
   - JSON-aware IList<> List Storage
   - JSON-aware IKeyValue<> Dictionary Storage
   - Collections Factory for IList<> and IKeyValue<> Instances

    In respect to generics.collections, this unit uses interfaces as variable
   holders, and leverage them to reduce the generated code as much as possible,
   as the Spring4D 2.0 framework does, but for both Delphi and FPC.
    It also publishes TDynArray and TSynDictionary high-level features like
   JSON/binary serialization or thread safety with Generics strong typing.

  *****************************************************************************
}

interface

{$I ..\mormot.defines.inc}

{$ifdef HASGENERICS} // do-nothing unit on oldest compilers (e.g. < Delphi 2010)

uses
  classes,
  contnrs,
  sysutils,
  mormot.core.base,
  mormot.core.os,
  mormot.core.unicode,
  mormot.core.text,
  mormot.core.buffers,
  mormot.core.data,
  mormot.core.rtti,
  mormot.core.json;


// note: defined "var value"  instead of "out value" to avoid finalizer calls


{ ************** JSON-aware IList<> List Storage }

type
  /// interface to iterate over a generic collection of a specific type
  // - we redefined our own type because RTL IEnumerator<T> is inconsistent
  // between Delphi and FPC
  ISynEnumerator<T> = interface
    // some property accessor
    function GetCurrent: T;
    /// go to the next item iterated in this collection
    function MoveNext: boolean;
    /// returns the current item in this collection
    property Current: T
      read GetCurrent;
  end;

  /// exception class raised by IList<T>
  ESynList = class(ESynException);

  /// how Collections.NewList<T> will handle its IList<T> storage
  TSynListOptions = set of (
    aoCaseInsensitive);

  /// gives access to a generics-based collection of items
  // - as generated by Collections.NewList<T> main factory
  IList<T> = interface
    // some property accessors
    function GetItem(ndx: PtrInt): T;
    procedure SetItem(ndx: PtrInt; const value: T);
    function GetCount: PtrInt;
    procedure SetCount(value: PtrInt);
    function GetCapacity: PtrInt;
    procedure SetCapacity(value: PtrInt);
    /// append a new value to the collection
    function Add(const value: T): PtrInt;
    /// insert a new value to the collection
    procedure Insert(ndx: PtrInt; const value: T);
    /// delete one item inside the collection
    // - the deleted item is finalized if necessary
    function Delete(ndx: PtrInt): boolean;
    /// get and remove the last item stored in the collection
    // - Add + Pop will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied and removed
    // - set keepvalue=true if you don't want to remove the item - i.e. Pick
    function Pop(var dest: T; keepvalue: boolean = false): boolean;
    /// delete all stored items
    procedure Clear;
    /// allows to iterate over a generic collection of a specific type
    // - we redefined our own type with its own method because RTL IEnumerable<T>
    // is inconsistent between Delphi and FPC
    function GetEnumerator: ISynEnumerator<T>;
    /// high-level access to the stored values from their associated indexes
    // - returns nil or do nothing if the supplied index is out of range
    property Items[ndx: PtrInt]: T
      read GetItem write SetItem; default;
    /// low-level pointer over the first item of the collection
    // - could be used to quickly lookup all items of the array, using Count
    // - can be nil if there is no item stored yet
    function First: pointer;
    /// returns a dynamic array containing data of this collection
    // - is a convenient way to consume such a list as regular SOA parameters
    // - Offset/Limit could be used to create a new dynamic array with some part
    // of the existing content (Offset<0 meaning from the end):
    // ! Array := List.AsArray;         // whole data assigned with refcount
    // ! Array := List.AsArray(10);     // items 10..Count-1
    // ! Array := List.AsArray(0, 10);  // first 0..9 items
    // ! Array := List.AsArray(10, 20); // items 10..29 - truncated if Count<30
    // ! Array := List.AsArray(-10);    // last Count-10..Count-1 items
    function AsArray(Offset: integer = 0; Limit: integer = 0): TArray<T>;
    /// returns the number of items actually stored
    // - you can also set the Count value then fill it with Items[]
    property Count: PtrInt
      read GetCount write SetCount;
    /// returns the internal array capacity
    property Capacity: PtrInt
      read GetCapacity write SetCapacity;
    /// low-level access to the internal TDynArray wrapper
    // - you can use e.g. Data.SaveToJson/SaveTo and
    // Data.LoadFromJson/LoadFromBinary
    function Data: PDynArray;
  end;

  /// abstract parent of TSynListSpecialized<T> to reduce code size
  // - contains all fields and methods not explicitly related to type T
  TSynListAbstract = class(TInterfacedObject)
  protected
    fCount: PtrInt;  // external TDynArray count
    fValue: pointer; // holds the actual dynamic array of <T>
    fDynArray: TDynArray;
    function DoPop(var dest; keepvalue: boolean): boolean;
    // some property accessors
    function GetCount: PtrInt;
    procedure SetCount(value: PtrInt);
    function GetCapacity: PtrInt;
    procedure SetCapacity(value: PtrInt);
  public
    /// initialize the array storage, specifying dynamic array type
    // - do not use this constructor, but Collections.NewList<T> class factory
    // - here aItemTypeInfo is required to be specified, since may not match T
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - by default, string values would be searched following exact case,
    // unless the aoCaseInsensitive option is set
    // - if aSortAs is ptNone, will guess the comparison/sort function from RTTI
    constructor Create(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; aSortAs: TRttiParserType);
    /// finalize the array storage, mainly the internal TDynArray
    destructor Destroy; override;
    /// delete one item inside the collection
    // - the deleted item is finalized if necessary
    function Delete(ndx: PtrInt): boolean;
    /// delete all stored items
    procedure Clear;
    /// low-level add an item to the dynamic array, returning its pointer
    function NewPtr: pointer;
    /// low-level pointer over the first item of the collection
    // - could be used to quickly lookup all items of the array, using Count
    // - can be nil if there is no item stored yet
    // - just a wrapper around fValue
    function First: pointer;
    /// returns the number of items actually stored
    property Count: PtrInt
      read fCount write SetCount;
    /// returns the internal array capacity
    property Capacity: PtrInt
      read GetCapacity write SetCapacity;
    /// low-level access to the internal TDynArray wrapper
    function Data: PDynArray;
  end;

  /// generics-based collection storage
  // - is a high level wrapper around our regular TDynArray
  // - main factory is Collections.NewList<T> class function, which returns a
  // IList<T> interface for reusing most class specializations: you should
  // NOT have to define a TSynListSpecialized<T> instance anywhere
  TSynListSpecialized<T> = class(TSynListAbstract, IList<T>)
  protected
    // some property accessors
    function GetItem(ndx: PtrInt): T;
    procedure SetItem(ndx: PtrInt; const value: T);
  public
    /// append a new value to the collection
    function Add(const value: T): PtrInt;
    /// insert a new value to the collection
    procedure Insert(ndx: PtrInt; const value: T);
    /// get and remove the last item stored in the collection
    // - Add + Pop will implement a LIFO (Last-In-First-Out) stack
    // - returns true if the item was successfully copied and removed
    // - set keepvalue=true if you don't want to remove the item - i.e. Pick
    function Pop(var dest: T; keepvalue: boolean = false): boolean;
    /// returns a dynamic array containing data of this collection
    // - is a convenient way to consume such a list as regular SOA parameters
    function AsArray(Offset: integer = 0; Limit: integer = 0): TArray<T>;
    /// allows to iterate over a generic collection of this specific type
    function GetEnumerator: ISynEnumerator<T>;
    /// allows to iterate over some range of the generic collection
    function Range(Offset: integer = 0; Limit: integer = 0): ISynEnumerator<T>;
    /// high-level access to the stored values from their associated indexes
    // - returns nil or do nothing if the supplied index is out of range
    property Items[ndx: PtrInt]: T
      read GetItem write SetItem; default;
  end;

  /// abstract parent of TSynEnumerator<T> to reduce code size
  // - contains all fields and methods not explicitly related to type T
  TSynEnumeratorAbstract = class(TInterfacedObject)
  protected
    fItemSize, fCurrent, fAfter: PtrUInt;
    function GetEnumerator: TSynEnumeratorAbstract;
  public
    /// setup the enumerator class
    constructor Create(const Value: TSynListAbstract); overload;
    /// setup the enumerator class for a slice
    constructor Create(const Value: TSynListAbstract;
      Offset, Limit: PtrInt); overload;
    /// go to the next item iterated in this collection
    function MoveNext: boolean; inline;
  end;

  /// process iteration over a ISynEnumerable<T> collection of a specific type
  TSynEnumerator<T> = class(TSynEnumeratorAbstract, ISynEnumerator<T>)
  protected
    type
      PT = ^T;
    // some property accessor
    function GetCurrent: T;
  public
    /// returns the current item in this collection
    property Current: T
      read GetCurrent;
  end;




{ ************** JSON-aware IKeyValue<> Dictionary Storage }

type
  /// exception class raised by TSynKeyValueSpecialized<TKey, TValue>
   ESynKeyValue = class(ESynException);

  /// gives access to a generics-based dictionary holding key/value pairs
  // - as generated by Collections.NewKeyValue<TKey, TValue> main factory
  IKeyValue<TKey, TValue> = interface
    // some property accessors
    function GetItem(const key: TKey): TValue;
    procedure SetItem(const key: TKey; const value: TValue);
    function GetCapacity: integer;
    procedure SetCapacity(value: integer);
    function GetTimeOutSeconds: cardinal;
    procedure SetTimeOutSeconds(value: cardinal);
    /// add a key/value pair to be unique
    // - raise an  ESynKeyValue if key was already set
    // - use default Items[] property to add or replace a key/value pair
    procedure Add(const key: TKey; const value: TValue);
    /// add a key/value pair if key is not existing
    // - returns true if was added, false if key was already set
    // - use default Items[] property to add or replace a key/value pair
    function TryAdd(const key: TKey; const value: TValue): boolean;
    /// search a key and return the associated key pair
    // - returns true if the key was found, false otherwise
    function TryGetValue(const key: TKey; var value: TValue): boolean;
    /// search a key and return the associated key pair or its default value
    function GetValueOrDefault(const key: TKey): TValue; overload;
    /// search a key and return the associated key pair or a supplied default value
    function GetValueOrDefault(const key: TKey; const defaultValue: TValue): TValue; overload;
    /// remove a key/value pair
    // - returns true if the entry was deleted, false if key was not found
    function Remove(const key: TKey): boolean;
    /// search a key, get the associated value, then delete the key/value pair
    function Extract(const key: TKey; var value: TValue): boolean;
    /// search for a key/value pair from a key
    // - returns true if the key was found, false otherwise
    function ContainsKey(const key: TKey): boolean;
    /// search for a key/value pair from a value
    // - returns true if the value was found, false otherwise
    function ContainsValue(const value: TValue): boolean;
    /// search and delete all deprecated items according to TimeoutSeconds
    // - returns how many items have been deleted
    // - you can call this method very often: it will ensure that the
    // search process will take place at most once every second
    function DeleteDeprecated: integer;
    /// delete all stored key/value pairs
    procedure Clear; overload;
    /// delete one stored key/value pairs from its key
    function Clear(const key: TKey): boolean; overload;
    /// high-level access to the stored values from their associated keys
    // - raise an  ESynKeyValue if the key is not available, unless
    // kvoDefaultIfNotFound option was set
    // - use TryGetValue() if you want to detect non available key
    property Items[const key: TKey]: TValue
      read GetItem write SetItem; default;
    /// returns the number of key/value pairs actually stored
    function Count: integer;
    /// returns the internal TSynDictionary capacity
    property Capacity: integer
      read GetCapacity write SetCapacity;
    /// returns the aTimeOutSeconds parameter value, as specified to Create()
    // - warning: setting a new timeout will clear all previous content
    property TimeOutSeconds: cardinal
      read GetTimeOutSeconds write SetTimeOutSeconds;
    /// low-level access to the internal TSynDictionary storage
    // - since this class is thread-safe, you could use this method to
    // manually access its content
    // - you can use e.g. Data.SaveToJson/SaveToBinary and
    // Data.LoadFromJson/LoadFromBinary
    function Data: TSynDictionary;
  end;

  /// how TSynKeyValueSpecialized<TKey, TValue>.Create() will handle its storage
  TSynKeyValueOptions = set of (
    kvoKeyCaseInsensitive,
    kvoThreadSafe,
    kvoDefaultIfNotFound);

  /// stack parameters to ease TSynKeyValueSpecialized<TKey, TValue> creation
  TNewSynKeyValueContext = record
    Options: TSynKeyValueOptions;
    KeyArrayTypeInfo, KeyItemTypeInfo: PRttiInfo;
    ValueArrayTypeInfo, ValueItemTypeInfo: PRttiInfo;
    Timeout: cardinal;
    Compress: TAlgoCompress;
    Hasher: THasher;
  end;

  /// abstract parent of TSynKeyValueSpecialized<TKey, TValue> to reduce code size
  // - contains all fields and methods not explicitly related to TKey/TValue
  TSynKeyValueAbstract = class(TInterfacedObject)
  protected
    fData: TSynDictionary;
    fKeyTypeInfo, fValueTypeInfo: PRttiInfo;
    fOptions: TSynKeyValueOptions;
    procedure AddOne(const key, value);
    procedure GetOne(const key; var value);
    procedure GetOneOrDefault(const key; var value);
    function GetCapacity: integer;
    procedure SetCapacity(value: integer);
    function GetTimeOutSeconds: cardinal;
    procedure SetTimeOutSeconds(value: cardinal);
  public
    /// initialize the dictionary storage, specifyng dynamic array keys/values
    // - main factory is Collections.NewKeyValue<TKey, TValue> class function,
    // which returns a IKeyValue<> interface for reusing most class specializations:
    // you should NOT call any TSynKeyValueSpecialized<> constructor anywhere
    constructor Create(const aContext: TNewSynKeyValueContext); reintroduce; virtual;
    /// finalize the dictionary storage
    destructor Destroy; override;
    /// search and delete all deprecated items according to TimeoutSeconds
    // - returns how many items have been deleted
    // - you can call this method very often: it will ensure that the
    // search process will take place at most once every second
    function DeleteDeprecated: integer;
    /// delete all stored key/value pairs
    procedure Clear; overload;
    /// returns the number of key/value pairs actually stored
    function Count: integer;
    /// returns the internal TSynDictionary capacity
    property Capacity: integer
      read GetCapacity write SetCapacity;
    /// returns the aTimeOutSeconds parameter value, as supplied to Create()
    // - warning: setting a new timeout will clear all previous content
    property TimeOutSeconds: cardinal
      read GetTimeOutSeconds write SetTimeOutSeconds;
    /// low-level access to the internal TSynDictionary storage
    // - since this class is thread-safe, you could use this method to
    // manually access its content
    // - you can use e.g. Data.SaveToJson/SaveToBinary and
    // Data.LoadFromJson/LoadFromBinary
    function Data: TSynDictionary;
    /// low-level access to the TSynKeyValueOptions as supplied to Create()
    property Options: TSynKeyValueOptions
      read fOptions;
    /// low-level access to TypeInfo(TKey) - match fData.Keys.Info as array
    property KeyTypeInfo: PRttiInfo
      read fKeyTypeInfo;
    /// low-level access to TypeInfo(TValue) - match fData.Values.Info as array
    property ValueTypeInfo: PRttiInfo
      read fValueTypeInfo;
  end;

  /// thread-safe generics-based dictionary holding key/value pairs
  // - is a high level wrapper around our regular TSynDictionary
  // - main factory is Collections.NewKeyValue<TKey, TValue> class function, which
  // returns a IKeyValue<> interface for reusing most class specializations: you
  // should NOT directly use a TSynKeyValueSpecialized<> anywhere
  TSynKeyValueSpecialized<TKey, TValue> = class(
    TSynKeyValueAbstract, IKeyValue<TKey, TValue>)
  protected
    // some property accessors
    function GetItem(const key: TKey): TValue;
    procedure SetItem(const key: TKey; const value: TValue);
  public
    /// add a key/value pair to be unique
    // - raise an  ESynKeyValue if key was already set
    // - use default Items[] property to add or replace a key/value pair
    procedure Add(const key: TKey; const value: TValue);
    /// add a key/value pair if key is not existing
    // - returns true if was added, false if key was already set
    // - use default Items[] property to add or replace a key/value pair
    function TryAdd(const key: TKey; const value: TValue): boolean;
    /// search a key and return the associated key pair
    // - returns true if the key was found, false otherwise
    function TryGetValue(const key: TKey; var value: TValue): boolean;
    /// search a key and return the associated key pair or its default value
    function GetValueOrDefault(const key: TKey): TValue; overload;
    /// search a key and return the associated key pair or a supplied default value
    function GetValueOrDefault(const key: TKey;
      const defaultValue: TValue): TValue; overload;
    /// remove a key/value pair
    // - returns true if the entry was deleted, false if key was not found
    function Remove(const key: TKey): boolean;
    /// search a key, get the associated value, then delete the key/value pair
    function Extract(const key: TKey; var value: TValue): boolean;
    /// search for a key/value pair from a key
    // - returns true if the key was found, false otherwise
    function ContainsKey(const key: TKey): boolean;
    /// search for a key/value pair from a value
    // - returns true if the value was found, false otherwise
    function ContainsValue(const value: TValue): boolean;
    /// delete one stored key/value pairs from its key
    function Clear(const key: TKey): boolean; overload;
    /// high-level access to the stored values from their associated keys
    // - raise an  ESynKeyValue if the key is not available, unless
    // kvoDefaultIfNotFound option was set
    // - use TryGetValue/GetValueOrDefault to detect non available key
    property Items[const key: TKey]: TValue
      read GetItem write SetItem; default;
  end;



{ ************ Collections Factory for IList<> and IKeyValue<> Instances }

type
  /// various factories to create instances of our generic collections
  // - this is main entry point of mormot.core.collections unit
  // - you should never call TSynListSpecialized<T>.Create nor
  // TSynKeyValueSpecialized<TKey, TValue>.Create constructors, but the static
  // Collections.NewList<T> and Collections.NewKeyValue<TKey, TValue> methods
  Collections = class
  protected
    {$ifdef HASGETTYPEKIND}
    {$ifdef FPC}
    const
      tkLString = tkAString; // circumvent FPC RTTI incompatibility
    {$endif FPC}
    // dedicated factories for most common TSynListSpecialized<T> types
    class procedure NewOrdinal(aSize: integer; aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewLString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewWString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewUString(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewInterface(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    class procedure NewVariant(aOptions: TSynListOptions;
      aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result); static;
    // dedicated factories for most common TSynKeyValueSpecialized<> types
    class procedure NewOrdinalOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeKey, aSizeValue: integer; var result); static;
    class procedure NewOrdinalLString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalWString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalUString(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalInterface(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewOrdinalVariant(const aContext: TNewSynKeyValueContext;
      aSizeKey: integer; var result); static;
    class procedure NewLStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewLStringManaged(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewWStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewWStringManaged(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewUStringOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewUStringManaged(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewInterfaceOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewInterfaceManaged(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    class procedure NewVariantOrdinal(const aContext: TNewSynKeyValueContext;
      aSizeValue: integer; var result); static;
    class procedure NewVariantManaged(const aContext: TNewSynKeyValueContext;
      aValue: TTypeKind; var result); static;
    // the RTTI is too complex -> should call NewPlain*<>() methods instead
    class function RaiseUseNewPlainList(aItemTypeInfo: PRttiInfo): pointer; static;
    class function RaiseUseNewPlainKeyValue(
      const aContext: TNewSynKeyValueContext): pointer; static;
    {$endif HASGETTYPEKIND}
  public
    /// generate a new IList<T> instance for most simple types
    // - use this factory method instead of plain TSynListSpecialized<T>.Create
    // so that the types will be specifialized and compiled once in this unit
    // - by default, string values would be searched following exact case,
    // unless the aoCaseInsensitive option is set
    // - raise ESynList if T type is too complex: use NewPlainList<T>() instead
    class function NewList<T>(aOptions: TSynListOptions = [];
      aDynArrayTypeInfo: PRttiInfo = nil): IList<T>;
        static; {$ifdef FPC} inline; {$endif}
    /// generate a new IList<T> instance with exact TSynListSpecialized<T>
    // - to be called for complex types (e.g. managed records) when
    // NewList<T> fails and triggers ESynList
    // - by default, string values would be searched following exact case,
    // unless the aoCaseInsensitive option is set
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - if aSortAs is ptNone, will guess the comparison/sort function from RTTI
    // but you can force one e.g. to sort using a record first field
    class function NewPlainList<T>(aOptions: TSynListOptions = [];
      aDynArrayTypeInfo: PRttiInfo = nil; aSortAs: TRttiParserType = ptNone): IList<T>;
        static; {$ifdef FPC} inline; {$endif}
    /// generate a new IKeyValue<TKey, TValue> instance
    // - use this factory method instead of TSynKeyValueSpecialized<>.Create
    // so that the types will be specifialized and compiled once in this unit
    // - you can provide the dynamic array TypeInfo() of T if the types are too
    // complex, or not already registered to mormot.core.rtti
    // - by default, this instance won't be thread-safe unless the kvoThreadSafe
    // option is forced, so that process is protected with a TSynLocker mutex
    // - by default, string keys would be searched following exact case, unless
    // the kvoKeyCaseInsensitive option is set
    // - you can set an optional timeout period, in seconds - you should call
    // DeleteDeprecated periodically to search for deprecated items
    // - raise ESynKeyValue if T type is too complex: use NewPlainList<T>() instead
    class function NewKeyValue<TKey, TValue>(aOptions: TSynKeyValueOptions = [];
      aKeyDynArrayTypeInfo: PRttiInfo = nil; aValueDynArrayTypeInfo: PRttiInfo = nil;
      aTimeoutSeconds: cardinal = 0; aCompressAlgo: TAlgoCompress = nil;
      aHasher: THasher = nil): IKeyValue<TKey, TValue>;
        static; {$ifdef FPC} inline; {$endif}
    /// generate a new IKeyValue<TKey, TValue> instance with exact
    // TSynKeyValueSpecialized<TKey, TValue>
    // - to be called for complex types (e.g. managed records) when
    // NewKeyValue<TKey, TValue> fails and triggers ESynKeyValue
    class function NewPlainKeyValue<TKey, TValue>(aOptions: TSynKeyValueOptions = [];
      aKeyDynArrayTypeInfo: PRttiInfo = nil; aValueDynArrayTypeInfo: PRttiInfo = nil;
      aTimeoutSeconds: cardinal = 0; aCompressAlgo: TAlgoCompress = nil;
      aHasher: THasher = nil): IKeyValue<TKey, TValue>;
        static; {$ifdef FPC} inline; {$endif}
  end;


implementation


{ ************** JSON-aware IList<> List Storage }

{ TSynEnumeratorAbstract }

constructor TSynEnumeratorAbstract.Create(const Value: TSynListAbstract);
begin
  fCurrent := PtrUInt(Value.fValue);
  if fCurrent = 0 then
    exit;
  fItemSize := Value.fDynArray.Info.Cache.ItemSize;
  fAfter := fCurrent + fItemSize * PtrUInt(Value.fCount);
  dec(fCurrent, fItemSize);
end;

constructor TSynEnumeratorAbstract.Create(const Value: TSynListAbstract;
  Offset, Limit: PtrInt);
begin
  if Offset < 0 then
  begin
    inc(Offset, Value.fCount);
    if Offset < 0 then
      Offset := 0;
  end;
  if Offset >= Value.fCount then
    exit;
  fCurrent := PtrUInt(Value.fValue);
  if fCurrent = 0 then
    exit;
  if Limit = 0 then
    Limit := Value.fCount;
  if Offset + Limit > Value.fCount then
    Limit := Value.fCount - Offset;
  fItemSize := Value.fDynArray.Info.Cache.ItemSize;
  inc(fCurrent, fItemSize * PtrUInt(Offset));
  fAfter := fCurrent + fItemSize * PtrUInt(Limit);
  dec(fCurrent, fItemSize);
end;

function TSynEnumeratorAbstract.MoveNext: boolean;
var
  c: PtrUInt; // to enhance code generation
begin
  c := fItemSize + fCurrent;
  fCurrent := c;
  result := c < fAfter; // false if fCurrent=fItemSize=fAfter=0
end;

function TSynEnumeratorAbstract.GetEnumerator: TSynEnumeratorAbstract;
begin
  result := self;
end;


{ TSynEnumerator }

function TSynEnumerator<T>.GetCurrent: T;
begin
  result := PT(fCurrent)^; // faster than fDynArray^.ItemCopy()
end;


{ TSynListAbstract }

constructor TSynListAbstract.Create(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; aSortAs: TRttiParserType);
var
  r: PRttiInfo;
begin
  r := aDynArrayTypeInfo;
  if r = nil then
    r := TypeInfoToDynArrayTypeInfo(aItemTypeInfo, {exact=}false);
  if (r = nil) or
     (r ^.Kind <> rkDynArray) then
     raise ESynList.CreateUtf8(self,
       'Create: % should be a dynamic array of T', [r^.Name^]);
  fDynArray.InitSpecific(r, fValue, aSortAs, // aSortAs=ptNone = use RTTI
    @fCount, aoCaseInsensitive in aOptions);
  if (fDynArray.Info.ArrayRtti = nil) or
     ((aDynArrayTypeInfo <> nil) and
      (fDynArray.Info.ArrayRtti.Info <> aItemTypeInfo)) then
    raise ESynList.CreateUtf8(self,
      'Create: T does not match %', [aDynArrayTypeInfo.RawName]);
end;

destructor TSynListAbstract.Destroy;
begin
  inherited Destroy;
  fDynArray.Clear;
end;

function TSynListAbstract.Delete(ndx: PtrInt): boolean;
begin
  result := fDynArray.Delete(ndx);
end;

function TSynListAbstract.DoPop(var dest; keepvalue: boolean): boolean;
begin
  if keepvalue then
    result := fDynArray.Peek(dest)
  else
    result := fDynArray.Pop(dest);
end;

function TSynListAbstract.GetCount: PtrInt;
begin
  result := fCount;
end;

procedure TSynListAbstract.SetCount(value: PtrInt);
begin
  fDynArray.Count := value; // will resize the dynamic array
end;

function TSynListAbstract.GetCapacity: PtrInt;
begin
  result := fDynArray.Capacity;
end;

procedure TSynListAbstract.SetCapacity(value: PtrInt);
begin
  fDynArray.Capacity := value; // don't change Count, just dynamic array length
end;

procedure TSynListAbstract.Clear;
begin
  fDynArray.Clear;
end;

function TSynListAbstract.NewPtr: pointer;
begin
  result := fDynArray.NewPtr;
end;

function TSynListAbstract.First: pointer;
begin
  result := fValue;
end;

function TSynListAbstract.Data: PDynArray;
begin
  result := @fDynArray;
end;


{ TSynListSpecialized }

function TSynListSpecialized<T>.GetItem(ndx: PtrInt): T;
begin
  if PtrUInt(ndx) < PtrUInt(fCount) then
    result := TArray<T>(fValue)[ndx]
  else
    result := Default(T);
end;

procedure TSynListSpecialized<T>.SetItem(ndx: PtrInt; const value: T);
begin
  if PtrUInt(ndx) < PtrUInt(fCount) then
    TArray<T>(fValue)[ndx] := value;
end;

function TSynListSpecialized<T>.GetEnumerator: ISynEnumerator<T>;
begin
  result := TSynEnumerator<T>.Create(self);
end;

function TSynListSpecialized<T>.Range(Offset, Limit: integer): ISynEnumerator<T>;
begin
  result := TSynEnumerator<T>.Create(self, Offset, Limit);
end;

function TSynListSpecialized<T>.Add(const value: T): PtrInt;
begin
  result := fDynArray.Add(value);
end;

procedure TSynListSpecialized<T>.Insert(ndx: PtrInt; const value: T);
begin
  fDynArray.Insert(ndx, value);
end;

function TSynListSpecialized<T>.Pop(var dest: T; keepvalue: boolean): boolean;
begin
  result := DoPop(dest, keepvalue);
end;

function TSynListSpecialized<T>.AsArray(Offset, Limit: integer): TArray<T>;
begin // assign existing dynamic array instance to TArray<T> result
  fDynArray.SliceAsDynArray(@result, Offset, Limit);
end;



{ ************** JSON-aware IKeyValue<> Dictionary Storage }

{ TSynKeyValueAbstract }

// shared methods leveraged against all TSynKeyValueSpecialized<> to reduce exe code size

constructor TSynKeyValueAbstract.Create(const aContext: TNewSynKeyValueContext);
var
  k, v: PRttiInfo;
begin
  fOptions := aContext.Options;
  fKeyTypeInfo := aContext.KeyItemTypeInfo;
  fValueTypeInfo := aContext.ValueItemTypeInfo;
  // validate or recognize most simple dynamic arrays from its TKey/TValue types
  k := aContext.KeyArrayTypeInfo;
  if k = nil then
    k := TypeInfoToDynArrayTypeInfo(fKeyTypeInfo, {exact=}false);
  if (k = nil) or
     (k ^.Kind <> rkDynArray) then
     raise ESynKeyValue.CreateUtf8(self,
       'Create: % should be a dynamic array of TKey', [k^.Name^]);
  v := aContext.ValueArrayTypeInfo;
  if v = nil then
    v := TypeInfoToDynArrayTypeInfo(fValueTypeInfo, {exact=}false);
  if (v = nil) or
     (v^.Kind <> rkDynArray) then
     raise ESynKeyValue.CreateUtf8(self,
       'Create: % should be a dynamic array of TValue', [v^.Name^]);
  // initialize the associated dictionary
  fData := TSynDictionary.Create(k, v, kvoKeyCaseInsensitive in fOptions,
    aContext.Timeout, aContext.Compress, aContext.Hasher);
  if kvoThreadSafe in fOptions then
    fData.Options := [doSingleThreaded];
  if (fData.Keys.Info.ArrayRtti = nil) or
     ((aContext.KeyArrayTypeInfo <> nil) and
      (fData.Keys.Info.ArrayRtti.Info <> fKeyTypeInfo)) then
    raise ESynKeyValue.CreateUtf8(self, 'Create: TKey does not match %',
      [aContext.KeyArrayTypeInfo^.RawName]);
  if (fData.Values.Info.ArrayRtti = nil) or
     ((aContext.ValueArrayTypeInfo <> nil) and
      (fData.Values.Info.ArrayRtti.Info <> fValueTypeInfo)) then
    raise ESynKeyValue.CreateUtf8(self, 'Create: TValue does not match %',
      [aContext.ValueArrayTypeInfo^.RawName]);
end;

destructor TSynKeyValueAbstract.Destroy;
begin
  inherited Destroy;
  fData.Free;
end;

procedure TSynKeyValueAbstract.AddOne(const key, value);
begin
  if fData.Add(key, value) < 0 then
    raise ESynKeyValue.CreateUtf8(self, 'Add: duplicated key', []);
end;

procedure TSynKeyValueAbstract.GetOne(const key; var value);
begin
  if not fData.FindAndCopy(key, value) then
    if kvoDefaultIfNotFound in fOptions then
      fData.Values.ItemClear(@value)
    else
      raise ESynKeyValue.CreateUtf8(self, 'GetItem: key not found', []);
end;

procedure TSynKeyValueAbstract.GetOneOrDefault(const key; var value);
begin
  if not fData.FindAndCopy(key, value) then
    fData.Values.ItemClear(@value);
end;

function TSynKeyValueAbstract.GetCapacity: integer;
begin
  result := fData.Capacity;
end;

procedure TSynKeyValueAbstract.SetCapacity(value: integer);
begin
  fData.Capacity := value;
end;

function TSynKeyValueAbstract.GetTimeOutSeconds: cardinal;
begin
  result := fData.TimeOutSeconds;
end;

procedure TSynKeyValueAbstract.SetTimeOutSeconds(value: cardinal);
begin
  fData.TimeOutSeconds := value;
end;

function TSynKeyValueAbstract.DeleteDeprecated: integer;
begin
  result := fData.DeleteDeprecated;
end;

procedure TSynKeyValueAbstract.Clear;
begin
  fData.DeleteAll;
end;

function TSynKeyValueAbstract.Count: integer;
begin
  result := fData.Count;
end;

function TSynKeyValueAbstract.Data: TSynDictionary;
begin
  result := fData;
end;


{ TSynKeyValueSpecialized<TKey, TValue> }

function TSynKeyValueSpecialized<TKey, TValue>.GetItem(const key: TKey): TValue;
begin
  GetOne(key, result);
end;

procedure TSynKeyValueSpecialized<TKey, TValue>.SetItem(const key: TKey;
  const value: TValue);
begin
  fData.AddOrUpdate(key, value);
end;

procedure TSynKeyValueSpecialized<TKey, TValue>.Add(const key: TKey; const value: TValue);
begin
  AddOne(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.TryAdd(const key: TKey;
  const value: TValue): boolean;
begin
  result := fData.Add(key, value) >= 0;
end;

function TSynKeyValueSpecialized<TKey, TValue>.TryGetValue(const key: TKey;
  var value: TValue): boolean;
begin
  result := fData.FindAndCopy(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.GetValueOrDefault(const key: TKey): TValue;
begin
  GetOneOrDefault(key, result);
end;

function TSynKeyValueSpecialized<TKey, TValue>.GetValueOrDefault(const key: TKey;
  const defaultValue: TValue): TValue;
begin
  if not fData.FindAndCopy(key, result) then
    result := defaultValue;
end;

function TSynKeyValueSpecialized<TKey, TValue>.Remove(const key: TKey): boolean;
begin
  result := fData.Delete(key) >= 0;
end;

function TSynKeyValueSpecialized<TKey, TValue>.Extract(const key: TKey;
  var value: TValue): boolean;
begin
  result := fData.FindAndExtract(key, value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.ContainsKey(const key: TKey): boolean;
begin
  result := fData.Exists(key);
end;

function TSynKeyValueSpecialized<TKey, TValue>.ContainsValue(const value: TValue): boolean;
begin
  result := fData.ExistsValue(value);
end;

function TSynKeyValueSpecialized<TKey, TValue>.Clear(const key: TKey): boolean;
begin
  result := fData.Clear(key) >= 0;
end;



{ ************ Collections Factory for IList<> and IKeyValue<> Instances }

{ Collections }

{$ifdef HASGETTYPEKIND}

// since Delphi XE7 or FPC 3.2: generate the most common type specializations
// in this very unit, to reduce units and executable code size

class function Collections.RaiseUseNewPlainList(aItemTypeInfo: PRttiInfo): pointer;
begin
  raise ESynList.CreateUtf8('Collections.NewList<>: Type is too complex - ' +
    'use Collections.NewPlainList<%> instead', [aItemTypeInfo.RawName]);
    // we tried Delphi' "at ReturnAddress" but disabled to avoid internal errors
  result := nil; // returns something to please the Delphi compiler
end;

class function Collections.RaiseUseNewPlainKeyValue(
  const aContext: TNewSynKeyValueContext): pointer;
begin
  raise ESynKeyValue.CreateUtf8('Collections.NewKeyValue<>: Types are too ' +
    'complex - use Collections.NewPlainKeyValue<%, %> instead',
    [aContext.KeyItemTypeInfo.RawName, aContext.ValueItemTypeInfo.RawName]);
    // we tried Delphi' "at ReturnAddress" but disabled to avoid internal errors
  result := nil; // returns something to please the Delphi compiler
end;


// some shared TSynListSpecialized<> which could be reused for IList<>
// - ptNone below will use proper RTTI at runtime for process

class procedure Collections.NewOrdinal(aSize: integer; aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
var
  obj: pointer;
begin
  case aSize of
    1:
      obj := TSynListSpecialized<Byte>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    2:
      obj := TSynListSpecialized<Word>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    4:
      obj := TSynListSpecialized<Integer>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    8:
      obj := TSynListSpecialized<Int64>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    16:
      obj := TSynListSpecialized<THash128>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    32:
      obj := TSynListSpecialized<THash256>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
    64:
      obj := TSynListSpecialized<THash512>.Create(
        aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone);
  else
    obj := RaiseUseNewPlainList(aItemTypeInfo);
  end;
  // all IList<T> share the same VMT -> assign once
  IList<Byte>(result) := TSynListSpecialized<Byte>({%H-}obj);
end;

class procedure Collections.NewLString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<RawByteString>(result) := TSynListSpecialized<RawByteString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptNone); // may be RawUtf8/RawJson
end;

class procedure Collections.NewWString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<WideString>(result) := TSynListSpecialized<WideString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptWideString);
end;

class procedure Collections.NewUString(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<UnicodeString>(result) := TSynListSpecialized<UnicodeString>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptUnicodeString);
end;

class procedure Collections.NewInterface(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<IInterface>(result) := TSynListSpecialized<IInterface>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptInterface);
end;

class procedure Collections.NewVariant(aOptions: TSynListOptions;
  aDynArrayTypeInfo, aItemTypeInfo: PRttiInfo; var result);
begin
  IList<Variant>(result) := TSynListSpecialized<Variant>.Create(
    aOptions, aDynArrayTypeInfo, aItemTypeInfo, ptVariant);
end;


// some shared TSynKeyValueSpecialized<> which could be reused for IKeyValue<>

class procedure Collections.NewOrdinalOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeKey, aSizeValue: integer;
  var result);
var
  obj: pointer;
label
  err;
begin
  case aSizeKey of
    1:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Byte, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Byte, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Byte, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Byte, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Byte, THash128>.Create(aContext);
      else
err:    obj := RaiseUseNewPlainKeyValue(aContext);
      end;
    2:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Word, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Word, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Word, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Word, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Word, THash128>.Create(aContext);
      else
        goto err;
      end;
    4:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Integer, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Integer, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Integer, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Integer, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Integer, THash128>.Create(aContext);
      else
        goto err;
      end;
    8:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<Int64, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<Int64, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<Int64, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<Int64, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<Int64, THash128>.Create(aContext);
      else
        goto err;
      end;
    16:
      case aSizeValue of
        1:
          obj := TSynKeyValueSpecialized<THash128, Byte>.Create(aContext);
        2:
          obj := TSynKeyValueSpecialized<THash128, Word>.Create(aContext);
        4:
          obj := TSynKeyValueSpecialized<THash128, Integer>.Create(aContext);
        8:
          obj := TSynKeyValueSpecialized<THash128, Int64>.Create(aContext);
        16:
          obj := TSynKeyValueSpecialized<THash128, THash128>.Create(aContext);
      else
        goto err;
      end;
  else
    goto err;
  end;
  // all IKeyValue<TKey, TValue> share the same VMT -> assign once
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewOrdinalLString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, IInterface>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, IInterface>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, IInterface>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, IInterface>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, IInterface>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewOrdinalWString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, WideString>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, WideString>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, WideString>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, WideString>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, WideString>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewOrdinalUString(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, UnicodeString>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, UnicodeString>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, UnicodeString>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, UnicodeString>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, UnicodeString>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewOrdinalInterface(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, IInterface>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, IInterface>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, IInterface>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, IInterface>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, IInterface>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewOrdinalVariant(
  const aContext: TNewSynKeyValueContext; aSizeKey: integer; var result);
var
  obj: pointer;
begin
  case aSizeKey of
    1:
      obj := TSynKeyValueSpecialized<Byte, Variant>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Word, Variant>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Integer, Variant>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Int64, Variant>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<THash128, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewLStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<IInterface, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<IInterface, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<IInterface, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<IInterface, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<IInterface, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewLStringManaged(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    tkLString:
      obj := TSynKeyValueSpecialized<IInterface, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<IInterface, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<IInterface, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<IInterface, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<IInterface, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewWStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<WideString, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<WideString, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<WideString, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<WideString, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<WideString, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewWStringManaged(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    tkLString:
      obj := TSynKeyValueSpecialized<WideString, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<WideString, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<WideString, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<WideString, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<WideString, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewUStringOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<UnicodeString, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<UnicodeString, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<UnicodeString, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<UnicodeString, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<UnicodeString, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewUStringManaged(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    tkLString:
      obj := TSynKeyValueSpecialized<UnicodeString, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<UnicodeString, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<UnicodeString, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<UnicodeString, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<UnicodeString, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewInterfaceOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<IInterface, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<IInterface, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<IInterface, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<IInterface, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<IInterface, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewInterfaceManaged(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    tkLString:
      obj := TSynKeyValueSpecialized<IInterface, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<IInterface, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<IInterface, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<IInterface, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<IInterface, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewVariantOrdinal(
  const aContext: TNewSynKeyValueContext; aSizeValue: integer; var result);
var
  obj: pointer;
begin
  case aSizeValue of
    1:
      obj := TSynKeyValueSpecialized<Variant, Byte>.Create(aContext);
    2:
      obj := TSynKeyValueSpecialized<Variant, Word>.Create(aContext);
    4:
      obj := TSynKeyValueSpecialized<Variant, Integer>.Create(aContext);
    8:
      obj := TSynKeyValueSpecialized<Variant, Int64>.Create(aContext);
    16:
      obj := TSynKeyValueSpecialized<Variant, THash128>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class procedure Collections.NewVariantManaged(
  const aContext: TNewSynKeyValueContext; aValue: TTypeKind; var result);
var
  obj: pointer;
begin
  case aValue of
    tkLString:
      obj := TSynKeyValueSpecialized<Variant, RawByteString>.Create(aContext);
    tkWString:
      obj := TSynKeyValueSpecialized<Variant, WideString>.Create(aContext);
    tkUString:
      obj := TSynKeyValueSpecialized<Variant, UnicodeString>.Create(aContext);
    tkInterface:
      obj := TSynKeyValueSpecialized<Variant, IInterface>.Create(aContext);
    tkVariant:
      obj := TSynKeyValueSpecialized<Variant, Variant>.Create(aContext);
  else
    obj := RaiseUseNewPlainKeyValue(aContext);
  end;
  IKeyValue<Byte, Byte>(result) := TSynKeyValueSpecialized<Byte, Byte>({%H-}obj);
end;

class function Collections.NewList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo): IList<T>;
begin
  // GetTypeKind() SizeOf() IsManagedType() intrinsics to compile efficiently
  if IsManagedType(T) then
    case GetTypeKind(T) of
      tkLString:
        // reuse TSynListSpecialized<RawByteString> for all AnsiString
        NewLString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
      tkWString:
        // reuse TSynListSpecialized<WideString> for all WideString
        NewWString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
      tkUString:
        // reuse TSynListSpecialized<UnicodeString> for all UnicodeString
        NewUString(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
      tkInterface:
        // reuse TSynListSpecialized<IInterface> for all interfaces
        NewInterface(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
      tkVariant:
        // reuse TSynListSpecialized<Variant> for Variant
        NewVariant(aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
      // we can't reuse tkDynArray because its RTL is TypeInfo-specific
    else
      // even if NewPlainList<T>() is not called nor used, it would be generated
      // with its full TSynListSpecialized<T> for no benefit but exe bloating
      // -> explicit abort at runtime to let the user fix the code ASAP
      RaiseUseNewPlainList(TypeInfo(T));
    end
  else
    // reuse TSynListSpecialized<integers> for ordinals (including TObject)
    NewOrdinal(SizeOf(T), aOptions, aDynArrayTypeInfo, TypeInfo(T), result);
end;

{$else}

class function Collections.NewList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo): IList<T>;
begin
  // oldest Delphi will generate bloated code for each specific type
  result := TSynListSpecialized<T>.Create(
    aOptions, aDynArrayTypeInfo, TypeInfo(T), ptNone);
end;

{$endif HASGETTYPEKIND}

class function Collections.NewPlainList<T>(aOptions: TSynListOptions;
  aDynArrayTypeInfo: PRttiInfo; aSortAs: TRttiParserType): IList<T>;
begin
  result := TSynListSpecialized<T>.Create(
    aOptions, aDynArrayTypeInfo, TypeInfo(T), aSortAs);
end;

class function Collections.NewKeyValue<TKey, TValue>(
  aOptions: TSynKeyValueOptions; aKeyDynArrayTypeInfo: PRttiInfo;
  aValueDynArrayTypeInfo: PRttiInfo; aTimeoutSeconds: cardinal;
  aCompressAlgo: TAlgoCompress; aHasher: THasher): IKeyValue<TKey, TValue>;
var
  ctx: TNewSynKeyValueContext;
begin
  ctx.Options := aOptions;
  ctx.KeyArrayTypeInfo := aKeyDynArrayTypeInfo;
  ctx.KeyItemTypeInfo := TypeInfo(TKey);
  ctx.ValueArrayTypeInfo := aValueDynArrayTypeInfo;
  ctx.ValueItemTypeInfo := TypeInfo(TValue);
  ctx.Timeout := aTimeOutSeconds;
  ctx.Compress := aCompressAlgo;
  ctx.Hasher := aHasher;
  {$ifdef HASGETTYPEKIND}
  // GetTypeKind() SizeOf() IsManagedType() intrinsics to compile efficiently
  if IsManagedType(TKey) then
    case GetTypeKind(TKey) of
      tkLString:
        if IsManagedType(TValue) then
          NewLStringManaged(ctx, GetTypeKind(TValue), result)
        else
          NewLStringOrdinal(ctx, SizeOf(TValue), result);
      tkWString:
        if IsManagedType(TValue) then
          NewWStringManaged(ctx, GetTypeKind(TValue), result)
        else
          NewWStringOrdinal(ctx, SizeOf(TValue), result);
      tkUString:
        if IsManagedType(TValue) then
          NewUStringManaged(ctx, GetTypeKind(TValue), result)
        else
          NewUStringOrdinal(ctx, SizeOf(TValue), result);
      tkInterface:
        if IsManagedType(TValue) then
          NewInterfaceManaged(ctx, GetTypeKind(TValue), result)
        else
          NewInterfaceOrdinal(ctx, SizeOf(TValue), result);
      tkVariant:
        if IsManagedType(TValue) then
          NewVariantManaged(ctx, GetTypeKind(TValue), result)
        else
          NewVariantOrdinal(ctx, SizeOf(TValue), result);
    else
      RaiseUseNewPlainKeyValue(ctx);
    end
  else
    if IsManagedType(TValue) then
      case GetTypeKind(TValue) of
        tkLString:
          NewOrdinalLString(ctx, SizeOf(TKey), result);
        tkWString:
          NewOrdinalWString(ctx, SizeOf(TKey), result);
        tkUString:
          NewOrdinalUString(ctx, SizeOf(TKey), result);
        tkInterface:
          NewOrdinalInterface(ctx, SizeOf(TKey), result);
        tkVariant:
          NewOrdinalVariant(ctx, SizeOf(TKey), result);
      else
        RaiseUseNewPlainKeyValue(ctx);
      end
    else
      NewOrdinalOrdinal(ctx, SizeOf(TKey), SizeOf(TValue), result);
  {$else}
  // oldest Delphi will generate bloated code for each specific type
  result := TSynKeyValueSpecialized<TKey, TValue>.Create(ctx);
  {$endif HASGETTYPEKIND}
end;

class function Collections.NewPlainKeyValue<TKey, TValue>(
  aOptions: TSynKeyValueOptions; aKeyDynArrayTypeInfo: PRttiInfo;
  aValueDynArrayTypeInfo: PRttiInfo; aTimeoutSeconds: cardinal;
  aCompressAlgo: TAlgoCompress; aHasher: THasher): IKeyValue<TKey, TValue>;
var
  ctx: TNewSynKeyValueContext;
begin
  ctx.Options := aOptions;
  ctx.KeyArrayTypeInfo := aKeyDynArrayTypeInfo;
  ctx.KeyItemTypeInfo := TypeInfo(TKey);
  ctx.ValueArrayTypeInfo := aValueDynArrayTypeInfo;
  ctx.ValueItemTypeInfo := TypeInfo(TValue);
  ctx.Timeout := aTimeOutSeconds;
  ctx.Compress := aCompressAlgo;
  ctx.Hasher := aHasher;
  result := TSynKeyValueSpecialized<TKey, TValue>.Create(ctx);
end;

{$else}

implementation

{$endif HASGENERICS} // do-nothing unit on oldest compilers



end.
