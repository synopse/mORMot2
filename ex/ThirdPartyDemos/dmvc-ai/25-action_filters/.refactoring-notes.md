# Action Filters Refactoring Notes (v2)

## Summary

Refactored the 25-action_filters sample from **global server hooks** to **per-service filters**, demonstrating the more idiomatic mORMot2 approach.

## What Changed

### Before (v1 - Global Hooks)
```pascal
// Global hooks affected ALL services on the server
fServer.OnBeforeUri := OnBeforeUri;
fServer.OnAfterUri := OnAfterUri;

// Single handler for all requests
function OnBeforeUri(Ctxt: TRestServerUriContext): Boolean;
procedure OnAfterUri(Ctxt: TRestServerUriContext);
```

### After (v2 - Per-Service Filters)
```pascal
// Get specific service factory
Factory := fServer.Services.Info(TypeInfo(IActionFiltersApi)) as TServiceFactoryServer;

// Register filters on specific service only
Factory.OnMethodExecute := OnMethodExecute;    // Authorization/validation
Factory.AddInterceptor(OnInterceptMethod);     // Before/after logging

// Service-specific handlers with better context
function OnMethodExecute(Ctxt: TRestServerUriContext;
  const Method: TInterfaceMethod): Boolean;

procedure OnInterceptMethod(Sender: TInterfaceMethodExecuteRaw;
  Step: TInterfaceMethodExecuteEventStep);
```

## Key Benefits

| Aspect | Global (v1) | Per-Service (v2) |
|--------|------------|------------------|
| **Scope** | All services | Single service |
| **Isolation** | Shared state | No interference |
| **Composition** | Single hook | Multiple interceptors |
| **Testing** | Hard to mock | Easy to isolate |
| **Best Practice** | Not recommended | ✅ Idiomatic |

## Technical Changes

### 1. Action Filters Unit (`action.filters.pas`)

**Added:**
- `mormot.core.interfaces` - For `TInterfaceMethodExecuteRaw`
- `mormot.soa.server` - For `TServiceFactoryServer`

**Changed:**
- Constructor now accepts `TServiceFactoryServer` parameter
- `OnMethodExecute` replaces `OnBeforeUri` (different signature)
- `OnInterceptMethod` replaces `OnAfterUri` (different signature)
- Added timing tracking (`fStartTime`) for interceptor
- Interceptor handles three steps: `smsBefore`, `smsAfter`, `smsError`

**Key Differences:**
```pascal
// OLD: Global, URL-based
function OnBeforeUri(Ctxt: TRestServerUriContext): Boolean;
  actionName := Ctxt.Call^.Url;

// NEW: Service-level, method-based
function OnMethodExecute(Ctxt: TRestServerUriContext;
  const Method: TInterfaceMethod): Boolean;
  methodName := Method.InterfaceDotMethodName;
```

### 2. Server Unit (`server.pas`)

**Added:**
- `mormot.soa.server` to uses clause

**Changed:**
- Get service factory after registration
- Pass factory to middleware constructor
- Middleware now registers filters on factory, not global server

```pascal
// NEW: Get factory for specific service
Factory := fServer.Services.Info(TypeInfo(IActionFiltersApi)) as TServiceFactoryServer;
fActionFilterMiddleware := TActionFilterMiddleware.Create(fServer, Factory);
```

### 3. Main Program (`ActionFilters.dpr`)

**Changed:**
- Updated console output to reflect service-level filtering
- Added description of interceptor steps (smsBefore/smsAfter/smsError)

### 4. Documentation (`README.md`)

**Added:**
- "Benefits of Service-Level Filters" section
- Comparison table (Global vs Service-level)
- Example of multiple services with different policies
- "When to Use Each Approach" guide
- Updated mapping table with v1 and v2 columns

## Educational Value

This refactoring demonstrates:

1. **OnMethodExecute vs OnBeforeUri**: Authorization filter at service level
2. **AddInterceptor vs OnAfterUri**: Composable logging/metrics hooks
3. **Service Isolation**: Each service can have different filter policies
4. **Interceptor Steps**: `smsBefore`, `smsAfter`, `smsError` lifecycle
5. **Best Practices**: mORMot2 idiomatic service filtering

## Use Cases

### OnMethodExecute (Authorization)
- ✅ Block requests (return `False`)
- ✅ Validate inputs before execution
- ✅ Rate limiting
- ✅ Access control

### AddInterceptor (Logging/Metrics)
- ✅ Log execution before/after (`smsBefore`/`smsAfter`)
- ✅ Track timing and performance
- ✅ Handle errors (`smsError`)
- ✅ **Composable** - multiple interceptors can be registered
- ✅ Response transformation

## Testing

Compiled successfully with Delphi 12.0 (Release/Win32):
- ✅ No errors
- ⚠️ 8 hints (inline function expansion - cosmetic only)

## Migration Guide

To migrate from global hooks to service-level filters:

1. Add `mormot.soa.server` to uses clause
2. Get service factory: `Factory := Server.Services.Info(TypeInfo(IYourService)) as TServiceFactoryServer`
3. Replace `OnBeforeUri` with `OnMethodExecute` (different signature)
4. Replace `OnAfterUri` with `AddInterceptor` (different signature, handles smsBefore/smsAfter/smsError)
5. Update middleware constructor to accept factory
6. Register filters on factory instead of server

## Related mORMot2 Features

- **TServiceFactoryServer.OnMethodExecute**: Authorization hook (SAD Chapter 16.X.3)
- **TServiceFactoryServer.AddInterceptor**: Execution lifecycle hook
- **TInterfaceMethodExecuteRaw**: Access to method context
- **TInterfaceMethodExecuteEventStep**: smsBefore/smsAfter/smsError

---

**Date**: 2025-12-23
**mORMot2 Version**: trunk (latest)
**Status**: ✅ Complete and tested
