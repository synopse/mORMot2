# DMVCFramework vs mORMot2 Master-Details Implementation Comparison

This document compares the original DMVCFramework master_details sample with the mORMot2 port, highlighting key architectural differences and conversion patterns.

## High-Level Architecture Comparison

### DMVCFramework Approach
```
WebModule → Engine → Controllers → ActiveRecord Models → Database
```

- **Controller-based**: HTTP endpoints defined as controller class methods
- **ActiveRecord ORM**: Models handle their own persistence
- **Attribute routing**: `[MVCPath]` and `[MVCHTTPMethod]` define endpoints
- **Automatic relationships**: `OnAfterLoad` auto-loads related entities
- **Implicit state**: Models maintain their relationship data

### mORMot2 Approach
```
HTTP Server → REST Server → Service Interfaces → ORM Entities → Database
```

- **Interface-based services**: HTTP endpoints defined as interface methods
- **Repository pattern**: Services handle entity persistence via IRestOrm
- **Automatic routing**: Interface method names become endpoints
- **Manual relationships**: Explicit loading of related entities
- **Explicit state**: DTOs separate API shape from database structure

## Code Comparison by Feature

### 1. Entity Definition

**DMVC ActiveRecord (BusinessObjects.pas)**
```pascal
[MVCTable('orders')]
TOrder = class(TMVCActiveRecord)
private
  [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]
  fID: NullableUInt64;
  [MVCTableField('id_customer')]
  fIDCustomer: Integer;
  [MVCOwned]
  fDetails: TObjectList<TOrderDetail>;
protected
  procedure OnAfterLoad; override;              // Auto-loads details
  procedure OnAfterInsertOrUpdate; override;    // Auto-saves details
  procedure OnBeforeInsertOrUpdate; override;   // Auto-calculates totals
public
  property ID: NullableUInt64 read fID write fID;
  property OrderItems: TObjectList<TOrderDetail> read fDetails;
end;
```

**mORMot2 ORM (entities.pas)**
```pascal
TOrmOrder = class(TOrm)
private
  fCustomerID: Integer;
  fOrderDate: TDateTime;
  fTotal: Currency;
published
  property CustomerID: Integer read fCustomerID write fCustomerID;
  property OrderDate: TDateTime read fOrderDate write fOrderDate;
  property Total: Currency read fTotal write fTotal;
  // Note: No nested items - handled separately
end;
```

**Key Differences:**
- DMVC: Attributes define table mapping, relationships embedded
- mORMot2: Convention-based mapping, relationships handled externally
- DMVC: Lifecycle hooks (OnAfterLoad, OnBeforeInsert)
- mORMot2: No lifecycle hooks, explicit control flow

### 2. Loading Related Entities

**DMVC (automatic via OnAfterLoad)**
```pascal
procedure TOrder.OnAfterLoad;
var
  lList: TObjectList<TOrderDetail>;
begin
  inherited;
  // Auto-executed after loading order
  lList := TMVCActiveRecord.SelectRQL<TOrderDetail>(
    Format('eq(idOrder,%d)', [ID.Value]), 1000);
  try
    fDetails.Clear;
    fDetails.AddRange(lList);
    lList.OwnsObjects := False;
  finally
    lList.Free;
  end;
end;
```

**mORMot2 (explicit in service)**
```pascal
function TOrdersAPI.LoadOrderItems(orderid: TID): TOrderItemDTODynArray;
var
  items: TOrmOrderItemObjArray;
  i: PtrInt;
begin
  // Explicitly called when needed
  if fRest.RetrieveListObjArray(items, TOrmOrderItem,
    'OrderID=?', [orderid]) then
  try
    SetLength(Result, Length(items));
    for i := 0 to High(items) do
      Result[i] := OrmOrderItemToDTO(items[i]);
  finally
    ObjArrayClear(items);
  end;
end;
```

**Key Differences:**
- DMVC: Automatic loading via lifecycle hook
- mORMot2: Explicit loading when building DTOs
- DMVC: Returns ORM objects directly
- mORMot2: Converts to DTOs for API layer

### 3. Cascading Deletes

**DMVC (manual in controller)**
```pascal
procedure TOrdersController.DeleteOrderByID(id: Integer);
var
  Order: TOrder;
begin
  TMVCActiveRecord.CurrentConnection.StartTransaction;
  try
    Order := TMVCActiveRecord.GetByPk<TOrder>(id);
    try
      Order.Delete;  // Just deletes the order
    finally
      Order.Free;
    end;
    TMVCActiveRecord.CurrentConnection.Commit;
  except
    TMVCActiveRecord.CurrentConnection.Rollback;
    raise;
  end;
end;
```

**Note:** DMVC sample doesn't show cascading - items would be orphaned unless database has FK constraints.

**mORMot2 (explicit cascade in service)**
```pascal
function TOrdersAPI.DeleteOrder(id: TID): Boolean;
var
  items: TOrmOrderItemObjArray;
  i: PtrInt;
begin
  // First delete all order items (explicit cascade)
  if fRest.RetrieveListObjArray(items, TOrmOrderItem,
    'OrderID=?', [id]) then
  try
    for i := 0 to High(items) do
      fRest.Delete(TOrmOrderItem, items[i].ID);
  finally
    ObjArrayClear(items);
  end;

  // Then delete the order itself
  Result := fRest.Delete(TOrmOrder, id);
end;
```

**Key Differences:**
- DMVC: Relies on database FK constraints (not shown in sample)
- mORMot2: Explicit cascade delete in application code
- mORMot2: More control, works with any database

### 4. Controller/Service Definition

**DMVC Controller (Controllers.Orders.pas)**
```pascal
[MVCPath('/orders')]
TOrdersController = class(TMVCController)
public
  [MVCDoc('Returns the Order with the specified id')]
  [MVCPath('/($id)')]
  [MVCHTTPMethod([httpGET])]
  procedure GetOrderByID(id: Integer);

  [MVCDoc('Deletes the Order with the specified id')]
  [MVCPath('/($id)')]
  [MVCHTTPMethod([httpDelete])]
  procedure DeleteOrderByID(id: Integer);

  [MVCDoc('Creates a new Order')]
  [MVCPath]
  [MVCHTTPMethod([httpPOST])]
  procedure CreateOrder(const [MVCFromBody] Order: TOrder);
end;
```

**mORMot2 Service (api.interfaces.pas)**
```pascal
IOrdersAPI = interface(IInvokable)
  ['{B7C8D9E0-F1A2-4B3C-5D6E-7F8A9B0C1D2E}']

  // Routing is automatic from method names
  function GetOrderByID(id: TID): TOrderDTO;
  function DeleteOrder(id: TID): Boolean;
  function CreateOrder(const order: TOrderInputDTO): TID;
end;
```

**Key Differences:**
- DMVC: Class with procedures, attribute-based routing
- mORMot2: Interface with functions, convention-based routing
- DMVC: `Render()` methods for responses
- mORMot2: Function return values are auto-serialized
- DMVC: Method names can be arbitrary
- mORMot2: Method names define URL structure

### 5. Rendering Responses

**DMVC (manual rendering)**
```pascal
procedure TOrdersController.GetOrderByID(id: Integer);
begin
  try
    Render(ObjectDict().Add('data', TMVCActiveRecord.GetByPk<TOrder>(id)));
  except
    on E: EServiceException do
      raise EMVCException.Create(E.Message, '', 0, 404);
  end;
end;
```

Response:
```json
{
  "data": {
    "id": 1,
    "idCustomer": 100,
    "orderDate": "2025-12-19",
    "total": 42.00,
    "orderItems": [...]
  }
}
```

**mORMot2 (automatic serialization)**
```pascal
function TOrdersAPI.GetOrderByID(id: TID): TOrderDTO;
var
  order: TOrmOrder;
begin
  order := TOrmOrder.Create(fRest, id);
  try
    if order.ID = 0 then
      raise ERestException.CreateUtf8('Order with ID % not found', [id]);

    Result := OrmOrderToDTO(order);
    Result.items := LoadOrderItems(order.ID);
  finally
    order.Free;
  end;
end;
```

Response:
```json
{
  "result": {
    "id": 1,
    "customerid": 100,
    "orderdate": "2025-12-19T00:00:00",
    "total": 42.00,
    "items": [...]
  }
}
```

**Key Differences:**
- DMVC: Manual `Render()` with wrapper object
- mORMot2: Return value automatically serialized
- DMVC: Flexible response structure
- mORMot2: Standardized `{"result": ...}` envelope

### 6. Updating with Merge

**DMVC (merge helper)**
```pascal
procedure TOrdersController.UpdateOrderByID(
  const id: Integer;
  [MVCFromBody] OrderIn: TOrderIn);
var
  lCurrentOrder: TOrder;
begin
  lCurrentOrder := TMVCActiveRecord.GetByPk<TOrder>(id);
  try
    if OrderIn.IDCustomer.HasValue then
      lCurrentOrder.IDCustomer := OrderIn.IDCustomer.Value;

    // Merge helper compares and applies changes
    TMVCActiveRecord.Merge<TOrderDetail>(
      lCurrentOrder.OrderItems,
      OrderIn.OrderItems
    ).Apply(
      procedure(const OrderDetail: TOrderDetail;
                const EntityAction: TMVCEntityAction;
                var Handled: Boolean)
      begin
        case EntityAction of
          eaDelete: lCurrentOrder.OrderItems.Extract(OrderDetail);
          eaCreate: lCurrentOrder.AddOrderItem(OrderDetail.Clone);
          eaUpdate: lCurrentOrder.UpdateOrderItemByID(OrderDetail.ID, OrderDetail);
        end;
      end);

    lCurrentOrder.Update();
  finally
    lCurrentOrder.Free;
  end;
end;
```

**mORMot2 (explicit operations)**
```pascal
function TOrdersAPI.AddItemToOrder(orderid: TID;
  const item: TOrderItemInputDTO): TID;
var
  newItem: TOrmOrderItem;
begin
  newItem := TOrmOrderItem.Create;
  try
    newItem.OrderID := orderid;
    newItem.ArticleID := item.articleid;
    newItem.UnitPrice := item.unitprice;
    newItem.Discount := item.discount;
    newItem.Quantity := item.quantity;
    newItem.Description := item.description;
    newItem.ComputeTotal;

    Result := fRest.Add(newItem, True);
    RecalculateOrderTotal(orderid);  // Explicit recalculation
  finally
    newItem.Free;
  end;
end;
```

**Key Differences:**
- DMVC: Merge helper automatically determines create/update/delete
- mORMot2: Separate explicit methods for each operation
- DMVC: More concise for bulk updates
- mORMot2: More explicit control, easier to understand

### 7. Total Recalculation

**DMVC (automatic via OnBeforeInsertOrUpdate)**
```pascal
procedure TOrder.OnBeforeInsertOrUpdate;
begin
  inherited;
  RecalcTotals;  // Auto-called before save
end;

procedure TOrder.RecalcTotals;
begin
  fTotal := 0;
  for var lOrderItem in fDetails do
    fTotal := fTotal + lOrderItem.Total;
end;
```

**mORMot2 (explicit in service)**
```pascal
procedure TOrdersAPI.RecalculateOrderTotal(orderid: TID);
var
  order: TOrmOrder;
  items: TOrmOrderItemObjArray;
  total: Currency;
  i: PtrInt;
begin
  order := TOrmOrder.Create(fRest, orderid);
  try
    if order.ID = 0 then Exit;

    total := 0;
    if fRest.RetrieveListObjArray(items, TOrmOrderItem,
      'OrderID=?', [orderid]) then
    try
      for i := 0 to High(items) do
        total := total + items[i].Total;
    finally
      ObjArrayClear(items);
    end;

    order.Total := total;
    fRest.Update(order);
  finally
    order.Free;
  end;
end;

// Explicitly called after item changes
function AddItemToOrder(...): TID;
begin
  Result := fRest.Add(newItem, True);
  RecalculateOrderTotal(orderid);  // Explicit call
end;
```

**Key Differences:**
- DMVC: Automatic via lifecycle hook
- mORMot2: Explicit call after each item change
- DMVC: Calculated in memory from loaded items
- mORMot2: Reloads items from database for accuracy

## Summary of Conversion Patterns

| Pattern | DMVCFramework | mORMot2 |
|---------|---------------|---------|
| **Service Definition** | Controller class with procedures | Interface with functions |
| **Routing** | Attribute-based (`[MVCPath]`) | Convention-based (method names) |
| **HTTP Methods** | Attribute-based (`[MVCHTTPMethod]`) | Inferred from operation |
| **ORM Pattern** | ActiveRecord (models are smart) | Repository (services are smart) |
| **Entity Relationships** | Embedded with `[MVCOwned]` | Separate loading via DTOs |
| **Lifecycle Hooks** | OnAfterLoad, OnBeforeInsert, etc. | None (explicit control) |
| **Response Rendering** | Manual `Render()` calls | Automatic from return values |
| **Response Format** | Flexible structure | Standard `{"result": ...}` |
| **Error Handling** | Raise `EMVCException` | Raise `ERestException` |
| **Transactions** | Manual via CurrentConnection | Manual via fRest |
| **Validation** | Attributes on model | Manual in service |
| **Parameter Binding** | `[MVCFromBody]`, `[MVCFromQueryString]` | Automatic from parameters |

## Architectural Trade-offs

### DMVCFramework Strengths
- **Flexibility**: Attribute routing allows any URL structure
- **Rich lifecycle hooks**: Less boilerplate for common patterns
- **ActiveRecord familiarity**: Similar to Rails, Laravel patterns
- **Automatic merging**: Built-in merge helper for complex updates

### mORMot2 Strengths
- **Type safety**: Interface contracts enforced at compile time
- **Explicit control**: No "magic", clear control flow
- **Performance**: Faster serialization, lower memory overhead
- **DTO separation**: Clean API/database boundary
- **Convention over configuration**: Less attribute noise

## Migration Checklist

When porting from DMVC to mORMot2:

- [ ] Convert controller classes to service interfaces
- [ ] Remove routing attributes (use method names instead)
- [ ] Change procedures to functions with return values
- [ ] Create DTOs separate from ORM entities
- [ ] Extract `OnAfterLoad` logic to explicit loading functions
- [ ] Extract `OnBeforeInsert` logic to service methods
- [ ] Replace `Render()` calls with return values
- [ ] Replace `[MVCFromBody]` with regular parameters
- [ ] Convert `TMVCActiveRecord.GetByPk` to `TOrmEntity.Create(fRest, id)`
- [ ] Convert `entity.Insert` to `fRest.Add(entity, True)`
- [ ] Convert `entity.Update` to `fRest.Update(entity)`
- [ ] Convert `entity.Delete` to `fRest.Delete(TOrmEntity, id)`
- [ ] Implement explicit cascade deletes
- [ ] Replace merge helpers with explicit CRUD methods

## Conclusion

The mORMot2 port demonstrates that while the architectural approaches differ significantly, both frameworks can achieve the same functionality:

- **DMVC emphasizes conventions and lifecycle hooks** for rapid development
- **mORMot2 emphasizes explicit control and type safety** for maintainability

The choice depends on team preferences and project requirements. This example shows both approaches are viable for master-detail relationships, with mORMot2 requiring more explicit code but providing clearer control flow and better compile-time safety.
