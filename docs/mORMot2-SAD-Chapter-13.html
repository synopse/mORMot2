<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13. Server-Side ORM Processing</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 { color: #2c3e50; margin-top: 1.5em; }
        h1 { border-bottom: 2px solid #3498db; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em; }
        code {
            background-color: #f8f8f8;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f8f8;
            padding: 1em;
            overflow-x: auto;
            border-radius: 5px;
            border: 1px solid #ddd;
            line-height: 1.1;
            font-family: "Cascadia Code", "Fira Code", "Source Code Pro", "DejaVu Sans Mono", "Consolas", "Lucida Console", "Courier New", monospace;
            font-size: 13px;
            letter-spacing: 0;
            font-variant-ligatures: none;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            line-height: 1.1;
            font-family: inherit;
            letter-spacing: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            text-align: left;
        }
        th { background-color: #f8f8f8; }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            color: #666;
        }
        a { color: #3498db; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .toc { background: #f8f8f8; padding: 1em; border-radius: 5px; }
        .toc ul { list-style: none; padding-left: 1em; }
        .note { background: #fff3cd; padding: 1em; border-radius: 5px; margin: 1em 0; }
        .warning { background: #f8d7da; padding: 1em; border-radius: 5px; margin: 1em 0; }
    </style>
</head>
<body>
<h1>13. Server-Side ORM Processing</h1>
<p>
<em>Behind the Scenes</em>

</p>
<p>
This chapter explores how the server processes ORM requests, including URI routing, SQL generation, virtual tables, and server-side customization.

</p>
<hr>
<h2>13.1. Request Processing Flow</h2>
<h3>13.1.1. URI to SQL Pipeline</h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────┐
│  Client Request: GET /api/Customer/123                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. HTTP Server receives request                                │
│     TRestHttpServer.Request()                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Router matches URI pattern                                  │
│     TRestRouter → /api/Customer/123 → rnTableID                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Authentication check                                        │
│     TRestServer.SessionGetUser()                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. ORM processes request                                       │
│     IRestOrm.Retrieve() → SQL: SELECT * FROM Customer WHERE ID=1│
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Response as JSON                                            │
│     {&quot;ID&quot;:123,&quot;Name&quot;:&quot;ACME&quot;,&quot;Email&quot;:&quot;...&quot;}                      │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>13.1.2. Router Node Types</h3>
<table>
<thead>
<tr>
  <th>Node</th>
  <th>URI Pattern</th>
  <th>HTTP Methods</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>rnTable</code></td>
  <td><code>/root/TableName</code></td>
  <td>GET (list), POST (create)</td>
</tr>
<tr>
  <td><code>rnTableID</code></td>
  <td><code>/root/TableName/<id></code></td>
  <td>GET, PUT, DELETE</td>
</tr>
<tr>
  <td><code>rnTableIDBlob</code></td>
  <td><code>/root/TableName/<id>/BlobField</code></td>
  <td>GET, PUT</td>
</tr>
<tr>
  <td><code>rnTableMethod</code></td>
  <td><code>/root/TableName/<method></code></td>
  <td>GET, POST</td>
</tr>
<tr>
  <td><code>rnMethod</code></td>
  <td><code>/root/<method></code></td>
  <td>GET, POST</td>
</tr>
<tr>
  <td><code>rnInterface</code></td>
  <td><code>/root/Interface.Method</code></td>
  <td>POST</td>
</tr>
</tbody>
</table>
<hr>
<h2>13.2. SQL Generation</h2>
<h3>13.2.1. Automatic SQL from URI</h3>
<p>
The ORM translates REST requests to SQL:

</p>
<pre><code class="language-text">GET /api/Customer
→ SELECT ID, Name, Email, ... FROM Customer

GET /api/Customer/123
→ SELECT ID, Name, Email, ... FROM Customer WHERE ID=123

GET /api/Customer?where=Country%3D%27USA%27
→ SELECT ID, Name, Email, ... FROM Customer WHERE Country=&#x27;USA&#x27;

POST /api/Customer (body: {&quot;Name&quot;:&quot;ACME&quot;})
→ INSERT INTO Customer (Name) VALUES (&#x27;ACME&#x27;)

PUT /api/Customer/123 (body: {&quot;Name&quot;:&quot;Updated&quot;})
→ UPDATE Customer SET Name=&#x27;Updated&#x27; WHERE ID=123

DELETE /api/Customer/123
→ DELETE FROM Customer WHERE ID=123
</code></pre>
<h3>13.2.2. Query Parameters</h3>
<table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Description</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>where</code></td>
  <td>WHERE clause</td>
  <td><code>?where=Country='USA'</code></td>
</tr>
<tr>
  <td><code>select</code></td>
  <td>Fields to return</td>
  <td><code>?select=Name,Email</code></td>
</tr>
<tr>
  <td><code>limit</code></td>
  <td>Max results</td>
  <td><code>?limit=100</code></td>
</tr>
<tr>
  <td><code>offset</code></td>
  <td>Skip results</td>
  <td><code>?offset=50</code></td>
</tr>
<tr>
  <td><code>order</code></td>
  <td>ORDER BY</td>
  <td><code>?order=Name</code></td>
</tr>
</tbody>
</table>
<h3>13.2.3. Inlined JSON Parameters</h3>
<p>
Parameters can be embedded in WHERE clause:

</p>
<pre><code class="language-pascal">// Client sends
&#x27;Name = :(&quot;John&quot;):AND Age &gt; :(30):&#x27;

// Server extracts and binds
SQL: &#x27;SELECT ... WHERE Name = ? AND Age &gt; ?&#x27;
Params: [&#x27;John&#x27;, 30]
</code></pre>
<hr>
<h2>13.3. Virtual Tables</h2>
<h3>13.3.1. Storage Backends</h3>
<p>
The ORM can mix multiple storage backends:

</p>
<pre><code class="language-pascal">Model := TOrmModel.Create([
  TOrmUser,      // Internal SQLite3
  TOrmProduct,   // External PostgreSQL
  TOrmLog,       // MongoDB
  TOrmCache      // In-memory
]);

// Map to different backends
OrmMapExternal(Model, TOrmProduct, PostgresProps);
OrmMapMongoDB(Model, TOrmLog, MongoClient.Database[&#x27;logs&#x27;]);
Model.Props[TOrmCache].SetStorage(TRestStorageInMemory);
</code></pre>
<h3>13.3.2. How Virtual Tables Work</h3>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────┐
│                      SQLite3 Core                     │
│  SELECT * FROM Product, User WHERE Product.UserID = Us│
└─────────────────────────────────────────────────────────────────┘
        │                                    │
        │ Virtual Table                      │ Native Table
        ▼                                    ▼
┌───────────────────┐               ┌───────────────────┐
│   PostgreSQL      │               │   SQLite3 File    │
│   (Product)       │               │   (User)          │
└───────────────────┘               └───────────────────┘
</code></pre>
<h3>13.3.3. Cross-Database JOINs</h3>
<pre><code class="language-pascal">// This works even with mixed backends!
Server.Orm.ExecuteList([TOrmProduct, TOrmUser],
  &#x27;SELECT Product.Name, User.Email &#x27; +
  &#x27;FROM Product, User &#x27; +
  &#x27;WHERE Product.UserID = User.ID&#x27;);
</code></pre>
<hr>
<h2>13.4. Server-Side Events</h2>
<h3>13.4.1. OnBefore<em> Events</h3>
<p>
Execute before ORM operations:

</p>
<pre><code class="language-pascal">type
  TMyServer = class(TRestServerDB)
  protected
    function OnBeforeAdd(Table: TOrmClass; const Rec: TOrm): Boolean; override;
  end;

function TMyServer.OnBeforeAdd(Table: TOrmClass; const Rec: TOrm): Boolean;
begin
  // Validate before insert
  if Table = TOrmCustomer then
    if TOrmCustomer(Rec).Email = &#x27;&#x27; then
    begin
      Result := False;  // Reject insert
      Exit;
    end;
  Result := True;  // Allow insert
end;
</code></pre>
<h3>13.4.2. OnAfter</em> Events</h3>
<p>
Execute after ORM operations:

</p>
<pre><code class="language-pascal">procedure TMyServer.OnAfterDelete(Table: TOrmClass; const aID: TID);
begin
  // Audit trail
  LogEvent(Format(&#x27;Deleted %s #%d&#x27;, [Table.ClassName, aID]));

  // Cascade operations
  if Table = TOrmCustomer then
    Orm.Delete(TOrmOrder, &#x27;CustomerID = ?&#x27;, [aID]);
end;
</code></pre>
<h3>13.4.3. Event Signatures</h3>
<table>
<thead>
<tr>
  <th>Event</th>
  <th>Signature</th>
  <th>Return</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>OnBeforeAdd</code></td>
  <td><code>(Table, Rec): Boolean</code></td>
  <td>False = reject</td>
</tr>
<tr>
  <td><code>OnAfterAdd</code></td>
  <td><code>(Table, aID)</code></td>
  <td>-</td>
</tr>
<tr>
  <td><code>OnBeforeUpdate</code></td>
  <td><code>(Table, Rec): Boolean</code></td>
  <td>False = reject</td>
</tr>
<tr>
  <td><code>OnAfterUpdate</code></td>
  <td><code>(Table, Rec)</code></td>
  <td>-</td>
</tr>
<tr>
  <td><code>OnBeforeDelete</code></td>
  <td><code>(Table, aID): Boolean</code></td>
  <td>False = reject</td>
</tr>
<tr>
  <td><code>OnAfterDelete</code></td>
  <td><code>(Table, aID)</code></td>
  <td>-</td>
</tr>
</tbody>
</table>
<h3>13.4.4. TOrm Event Methods</h3>
<p>
Override in TOrm class for record-level events:

</p>
<pre><code class="language-pascal">type
  TOrmCustomer = class(TOrm)
  protected
    procedure ComputeFieldsBeforeWrite(const aRest: IRestOrm;
      aOccasion: TOrmEvent; aServerTimeStamp: TTimeLog = 0); override;
  end;

procedure TOrmCustomer.ComputeFieldsBeforeWrite(const aRest: IRestOrm;
  aOccasion: TOrmEvent; aServerTimeStamp: TTimeLog);
begin
  inherited;
  // Auto-compute fields before save
  if aOccasion in [oeAdd, oeUpdate] then
    fSearchText := LowerCase(fName + &#x27; &#x27; + fEmail);
end;
</code></pre>
<hr>
<h2>13.5. Server-Side Filtering</h2>
<h3>13.5.1. Access Control per Table</h3>
<pre><code class="language-pascal">// Restrict access to specific tables
Server.OnCanExecute := function(Sender: TRest; Context: TRestServerUriContext;
  Table: TOrmClass; const TableID: TID): Boolean
begin
  // Only admins can access TOrmSettings
  if Table = TOrmSettings then
    Result := Context.Session.User.GroupRights.HasRight(arAdmin)
  else
    Result := True;
end;
</code></pre>
<h3>13.5.2. Field-Level Security</h3>
<pre><code class="language-pascal">type
  TOrmUser = class(TOrm)
  private
    fName: RawUtf8;
    fPassword: RawUtf8;
    fInternalNote: RawUtf8;  // Never expose to clients
  published
    property Name: RawUtf8 read fName write fName;
    property Password: RawUtf8 read fPassword write fPassword;
    property InternalNote: RawUtf8 read fInternalNote write fInternalNote
      stored False;  // Not transmitted over REST
  end;
</code></pre>
<h3>13.5.3. Dynamic WHERE Injection</h3>
<p>
Force additional conditions on all queries:

</p>
<pre><code class="language-pascal">// All Customer queries filtered by tenant
Server.OnBeforeUriExecute := procedure(Sender: TRest; var SqlWhere: RawUtf8;
  Table: TOrmClass)
begin
  if Table = TOrmCustomer then
  begin
    if SqlWhere &lt;&gt; &#x27;&#x27; then
      SqlWhere := SqlWhere + &#x27; AND &#x27;;
    SqlWhere := SqlWhere + FormatUtf8(&#x27;TenantID = %&#x27;, [CurrentTenantID]);
  end;
end;
</code></pre>
<hr>
<h2>13.6. Server-Side Caching</h2>
<h3>13.6.1. Enable Table Caching</h3>
<pre><code class="language-pascal">// Cache entire table in memory
Server.Cache.SetCache(TOrmProduct);

// Cache with timeout
Server.Cache.SetTimeOut(TOrmProduct, 300000);  // 5 minutes

// Cache frequently accessed records
Server.Cache.SetCache(TOrmSettings, True);  // Force all records cached
</code></pre>
<h3>13.6.2. Cache Statistics</h3>
<pre><code class="language-pascal">WriteLn(&#x27;Cache hits: &#x27;, Server.Cache.CacheHits);
WriteLn(&#x27;Cache misses: &#x27;, Server.Cache.CacheMisses);
WriteLn(&#x27;Hit ratio: &#x27;, Server.Cache.CacheHits /
  (Server.Cache.CacheHits + Server.Cache.CacheMisses) * 100:0:1, &#x27;%&#x27;);
</code></pre>
<h3>13.6.3. Manual Cache Invalidation</h3>
<pre><code class="language-pascal">// Clear specific record
Server.Cache.NotifyDeletion(TOrmProduct, ProductID);

// Clear entire table
Server.Cache.Clear(TOrmProduct);

// Clear all caches
Server.Cache.Clear;
</code></pre>
<hr>
<h2>13.7. Write Modes</h2>
<h3>13.7.1. Direct vs Batch Mode</h3>
<pre><code class="language-pascal">// Direct mode (default): Each write goes to database immediately
Server.Orm.Add(Customer, True);  // INSERT executed now

// Batch mode on server: Use TRestBatch directly
var
  Batch: TRestBatch;
  Results: TIDDynArray;
begin
  Batch := TRestBatch.Create(Server.Orm, TOrmCustomer);
  try
    Batch.Add(Customer1, True);  // Queued
    Batch.Add(Customer2, True);  // Queued
    Server.Orm.BatchSend(Batch, Results);  // All INSERTs now
  finally
    Batch.Free;
  end;
end;
</code></pre>
<p>
<strong>Note</strong>: <code>BatchStart</code>/<code>BatchSend</code> methods without parameters are on <code>TRestClientUri</code>. Server-side code should use <code>TRestBatch</code> directly.

</p>
<h3>13.7.2. Transaction Handling</h3>
<pre><code class="language-pascal">const
  SESSION_ID = 1;  // Current session ID
begin
  // Automatic transactions per batch
  Server.TransactionBegin(TOrmCustomer, SESSION_ID);
  try
    Server.Orm.Add(Customer1, True);
    Server.Orm.Add(Customer2, True);
    Server.Commit(SESSION_ID, True);  // RaiseException=True
  except
    Server.RollBack(SESSION_ID);
    raise;
  end;
end;
</code></pre>
<p>
<strong>Note</strong>: Transaction methods require a <code>SessionID</code> parameter on the server.

</p>
<h3>13.7.3. Write Acknowledgment</h3>
<pre><code class="language-pascal">// Control write confirmation
Server.AcquireWriteMode := amLocked;       // Wait for write completion
Server.AcquireWriteMode := amUnlocked;     // Fire and forget (faster)
Server.AcquireWriteMode := amBackgroundThread;  // Queue to background
</code></pre>
<hr>
<h2>13.8. Static Storage</h2>
<h3>13.8.1. In-Memory Tables</h3>
<pre><code class="language-pascal">uses
  mormot.orm.storage;

// Register before server creation
Model.Props[TOrmCache].SetStorage(TRestStorageInMemory);

// Or add after server creation
Storage := TRestStorageInMemory.Create(TOrmCache, Server);
Server.StaticDataAdd(Storage);
</code></pre>
<h3>13.8.2. Persistence Options</h3>
<pre><code class="language-pascal">// JSON persistence
Storage := TRestStorageInMemory.Create(TOrmCache, Server);
Storage.FileName := &#x27;cache.json&#x27;;

// Binary persistence (faster, smaller)
Storage.BinaryFile := True;
Storage.FileName := &#x27;cache.data&#x27;;

// Manual save/load
Storage.SaveToFile(&#x27;backup.json&#x27;);
Storage.LoadFromFile(&#x27;backup.json&#x27;);
</code></pre>
<h3>13.8.3. Static vs Virtual</h3>
<table>
<thead>
<tr>
  <th>Feature</th>
  <th>Static</th>
  <th>Virtual</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SQL JOINs</td>
  <td>No</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Speed</td>
  <td>Faster</td>
  <td>Slightly slower</td>
</tr>
<tr>
  <td>Memory</td>
  <td>Dedicated</td>
  <td>Shared with SQLite3</td>
</tr>
<tr>
  <td>Use case</td>
  <td>Simple CRUD</td>
  <td>Complex queries</td>
</tr>
</tbody>
</table>
<hr>
<h2>13.9. Performance Monitoring</h2>
<h3>13.9.1. Server Statistics</h3>
<pre><code class="language-pascal">// Enable monitoring
Server.CreateMissingTables;

// Access statistics
WriteLn(&#x27;Total requests: &#x27;, Server.Stats.TotalRequestCount);
WriteLn(&#x27;Success: &#x27;, Server.Stats.SuccessRequestCount);
WriteLn(&#x27;Errors: &#x27;, Server.Stats.ErrorRequestCount);
WriteLn(&#x27;Avg response time: &#x27;, Server.Stats.AverageResponseTime, &#x27; ms&#x27;);
</code></pre>
<h3>13.9.2. Per-Table Statistics</h3>
<pre><code class="language-pascal">for i := 0 to Server.Model.TablesMax do
begin
  Stats := Server.Stats[i];
  if Stats &lt;&gt; nil then
    WriteLn(Server.Model.Tables[i].SqlTableName, &#x27;: &#x27;,
      Stats.SelectCount, &#x27; reads, &#x27;, Stats.InsertCount, &#x27; inserts&#x27;);
end;
</code></pre>
<h3>13.9.3. SQL Execution Logging</h3>
<pre><code class="language-pascal">// Enable SQL logging
TSynLog.Add.Level := [sllSQL, sllDB];

// Or specific callback
Server.OnSqlExecute := procedure(const SQL: RawUtf8; const TimeMS: Int64)
begin
  if TimeMS &gt; 100 then  // Log slow queries
    WriteLn(&#x27;SLOW QUERY (&#x27;, TimeMS, &#x27;ms): &#x27;, SQL);
end;
</code></pre>
<hr>
<h2>13.10. Custom ORM Extensions</h2>
<h3>13.10.1. Custom SQL Functions</h3>
<pre><code class="language-pascal">// Register custom SQLite3 function
Server.DB.RegisterSQLFunction(
  procedure(Context: TSqlite3FunctionContext; argc: Integer;
    var argv: TSqlite3ValueArray)
  begin
    // Custom function implementation
    sqlite3.result_int64(Context, CalculateHash(argv[0]));
  end,
  &#x27;MYHASH&#x27;, 1);

// Use in queries
Server.Orm.ExecuteList(TOrmCustomer,
  &#x27;SELECT * FROM Customer WHERE MYHASH(Name) = ?&#x27;, [HashValue]);
</code></pre>
<h3>13.10.2. Computed Fields</h3>
<pre><code class="language-pascal">type
  TOrmOrder = class(TOrm)
  private
    fQuantity: Integer;
    fUnitPrice: Currency;
    fTotal: Currency;
  protected
    procedure ComputeFieldsBeforeWrite(const aRest: IRestOrm;
      aOccasion: TOrmEvent; aServerTimeStamp: TTimeLog = 0); override;
  published
    property Quantity: Integer read fQuantity write fQuantity;
    property UnitPrice: Currency read fUnitPrice write fUnitPrice;
    property Total: Currency read fTotal write fTotal stored False;  // Computed
  end;

procedure TOrmOrder.ComputeFieldsBeforeWrite(const aRest: IRestOrm;
  aOccasion: TOrmEvent; aServerTimeStamp: TTimeLog);
begin
  inherited;
  fTotal := fQuantity * fUnitPrice;
end;
</code></pre>
<hr>
<h2>13.11. Migration from mORMot 1</h2>
<h3>13.11.1. ORM Access Change</h3>
<pre><code class="language-pascal">// mORMot 1: Direct access
Server.Add(Customer, True);
Server.Retrieve(123, Customer);

// mORMot 2: Via Orm property
Server.Orm.Add(Customer, True);
Server.Orm.Retrieve(123, Customer);
</code></pre>
<h3>13.11.2. Event Method Changes</h3>
<pre><code class="language-pascal">// mORMot 1
procedure TSQLRestServerDB.BeforeAdd;
procedure TSQLRestServerDB.AfterAdd;

// mORMot 2
function TRestServerDB.OnBeforeAdd: Boolean;
procedure TRestServerDB.OnAfterAdd;
</code></pre>
<h3>13.11.3. Static Storage Registration</h3>
<pre><code class="language-pascal">// mORMot 1
Server.StaticDataCreate(TOrmCache, &#x27;&#x27;, False, True);

// mORMot 2
Model.Props[TOrmCache].SetStorage(TRestStorageInMemory);
</code></pre>
<hr>
<p>
<em>Next Chapter: Method-Based Services</em>

</p>
<hr>
<h2>Navigation</h2>
<table>
<thead>
<tr>
  <th>Previous</th>
  <th>Index</th>
  <th>Next</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="mORMot2-SAD-Chapter-12.html">Chapter 12: Client-Server ORM Operations</a></td>
  <td><a href="mORMot2-SAD-Index.html">Index</a></td>
  <td><a href="mORMot2-SAD-Chapter-14.html">Chapter 14: Client-Server Services via Methods</a></td>
</tr>
</tbody>
</table>
</body>
</html>
