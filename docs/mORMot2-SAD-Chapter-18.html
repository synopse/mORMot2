<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>18. The MVC Pattern</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 { color: #2c3e50; margin-top: 1.5em; }
        h1 { border-bottom: 2px solid #3498db; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em; }
        code {
            background-color: #f8f8f8;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f8f8;
            padding: 1em;
            overflow-x: auto;
            border-radius: 5px;
            border: 1px solid #ddd;
            line-height: 1.1;
            font-family: "Cascadia Code", "Fira Code", "Source Code Pro", "DejaVu Sans Mono", "Consolas", "Lucida Console", "Courier New", monospace;
            font-size: 13px;
            letter-spacing: 0;
            font-variant-ligatures: none;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            line-height: 1.1;
            font-family: inherit;
            letter-spacing: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            text-align: left;
        }
        th { background-color: #f8f8f8; }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            color: #666;
        }
        a { color: #3498db; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .toc { background: #f8f8f8; padding: 1em; border-radius: 5px; }
        .toc ul { list-style: none; padding-left: 1em; }
        .note { background: #fff3cd; padding: 1em; border-radius: 5px; margin: 1em 0; }
        .warning { background: #f8d7da; padding: 1em; border-radius: 5px; margin: 1em 0; }
    </style>
</head>
<body>
<h1>18. The MVC Pattern</h1>
<p>
<em>Separating Concerns for Better Architecture</em>

</p>
<p>
The Model-View-Controller (MVC) pattern separates application concerns into three interconnected components. mORMot 2 provides a complete MVC implementation for both desktop and web applications, with the Mustache template engine as its primary view technology.

</p>
<hr>
<h2>18.1. MVC Architecture Overview</h2>
<h3>18.1.1. The Three Components</h3>
<table>
<thead>
<tr>
  <th>Component</th>
  <th>Responsibility</th>
  <th>mORMot Implementation</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Model</strong></td>
  <td>Data and business logic</td>
  <td><code>TOrm</code> classes, <code>TOrmModel</code>, <code>TRest</code></td>
</tr>
<tr>
  <td><strong>View</strong></td>
  <td>Presentation layer</td>
  <td>Mustache templates (<code>.html</code>), Desktop UI</td>
</tr>
<tr>
  <td><strong>Controller</strong></td>
  <td>User input handling</td>
  <td><code>IMvcApplication</code> interface methods</td>
</tr>
</tbody>
</table>
<h3>18.1.2. Benefits of MVC</h3>
<ul>
  <li><strong>Separation of concerns</strong>: Each component has a single responsibility</li>
  <li><strong>Testability</strong>: Logic can be tested without UI</li>
  <li><strong>Reusability</strong>: Same model for different views</li>
  <li><strong>Maintainability</strong>: Changes in one layer don't affect others</li>
  <li><strong>Team collaboration</strong>: Designers work on views, developers on logic</li>
</ul>
<h3>18.1.3. mORMot's MVC Stack</h3>
<pre><code class="language-text">┌──────────────────────────────────────────────┐
│                    View                      │
│  Mustache templates (.html) or Desktop UI    │
├──────────────────────────────────────────────┤
│                 Controller                   │
│  IMvcApplication interface implementation    │
├──────────────────────────────────────────────┤
│                   Model                      │
│     TOrm classes + TRest ORM/SOA             │
└──────────────────────────────────────────────┘
</code></pre>
<hr>
<h2>18.2. The Model Layer</h2>
<h3>18.2.1. ORM as the Model</h3>
<p>
In mORMot, the Model is your ORM classes and the <code>TOrmModel</code>:

</p>
<pre><code class="language-pascal">type
  TOrmAuthor = class(TOrm)
  private
    fName: RawUtf8;
    fEmail: RawUtf8;
  published
    property Name: RawUtf8 index 100 read fName write fName;
    property Email: RawUtf8 index 100 read fEmail write fEmail;
  end;

  TOrmArticle = class(TOrmTimestamped)
  private
    fTitle: RawUtf8;
    fContent: RawUtf8;
    fAuthor: TOrmAuthor;
    fPublished: Boolean;
  published
    property Title: RawUtf8 index 200 read fTitle write fTitle;
    property Content: RawUtf8 read fContent write fContent;
    property Author: TOrmAuthor read fAuthor write fAuthor;
    property Published: Boolean read fPublished write fPublished;
  end;

function CreateBlogModel: TOrmModel;
begin
  Result := TOrmModel.Create([TOrmAuthor, TOrmArticle], &#x27;blog&#x27;);
end;
</code></pre>
<h3>18.2.2. Model Best Practices</h3>
<p>
1. <strong>Keep models focused</strong>: Each <code>TOrm</code> class represents one entity
2. <strong>Use class hierarchy</strong>: Share common properties via inheritance
3. <strong>Define indexes</strong>: Override <code>InitializeTable</code> for performance
4. <strong>Add validation</strong>: Use <code>AddFilterNotVoidText</code> and similar methods
5. <strong>Document relationships</strong>: One-to-many, many-to-many via properties

</p>
<pre><code class="language-pascal">class procedure TOrmArticle.InitializeTable(const Server: IRestOrmServer;
  const FieldName: RawUtf8; Options: TOrmInitializeTableOptions);
begin
  inherited;
  if (FieldName = &#x27;&#x27;) or (FieldName = &#x27;Author&#x27;) then
    Server.CreateSqlIndex(TOrmArticle, &#x27;Author&#x27;, False);
end;
</code></pre>
<hr>
<h2>18.3. The View Layer</h2>
<p>
mORMot provides two view technologies:

</p>
<h3>18.3.1. Desktop Views (RTTI-based)</h3>
<p>
For desktop applications, UI can be generated from RTTI:

</p>
<pre><code class="language-pascal">type
  TBlogAction = (
    baNewArticle,
    baEditArticle,
    baDeleteArticle,
    baQuit
  );

const
  ToolbarActions: array[0..1] of set of TBlogAction = (
    [baNewArticle, baEditArticle, baDeleteArticle],
    [baQuit]
  );
</code></pre>
<p>
Benefits:
<ul>
  <li><strong>Camel Case to labels</strong>: <code>baNewArticle</code> becomes "New Article"</li>
  <li><strong>Automatic i18n</strong>: Labels can be translated</li>
  <li><strong>Type safety</strong>: Compiler checks action names</li>
  <li><strong>Code-first</strong>: UI defined in code, not visual designer</li>
</ul>
<h3>18.3.2. Web Views (Mustache Templates)</h3>
<p>
For web applications, Mustache templates provide logic-less rendering:

</p>
<pre><code class="language-html">&lt;!-- ArticleView.html --&gt;
&lt;article&gt;
  &lt;h1&gt;{{Article.Title}}&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;By {{Author.Name}} on {{Article.CreatedAt}}&lt;/p&gt;
  &lt;div class=&quot;content&quot;&gt;
    {{{Article.Content}}}
  &lt;/div&gt;

  {{#WithComments}}
  &lt;section class=&quot;comments&quot;&gt;
    &lt;h2&gt;Comments&lt;/h2&gt;
    {{#Comments}}
    &lt;div class=&quot;comment&quot;&gt;
      &lt;strong&gt;{{Title}}&lt;/strong&gt;
      &lt;p&gt;{{Content}}&lt;/p&gt;
    &lt;/div&gt;
    {{/Comments}}
    {{^Comments}}
    &lt;p&gt;No comments yet.&lt;/p&gt;
    {{/Comments}}
  &lt;/section&gt;
  {{/WithComments}}
&lt;/article&gt;
</code></pre>
<hr>
<h2>18.4. The Mustache Template Engine</h2>
<h3>18.4.1. Why Mustache?</h3>
<p>
Mustache is a <strong>logic-less</strong> template system:
<ul>
  <li>No <code>if</code> statements or loops in templates</li>
  <li>Data context determines what renders</li>
  <li>Clean separation of logic and presentation</li>
  <li>Same templates work client-side (JavaScript) and server-side</li>
</ul>
<h3>18.4.2. Basic Syntax</h3>
<table>
<thead>
<tr>
  <th>Tag</th>
  <th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>{{variable}}</code></td>
  <td>HTML-escaped output</td>
</tr>
<tr>
  <td><code>{{{variable}}}</code></td>
  <td>Unescaped output (raw HTML)</td>
</tr>
<tr>
  <td><code>{{#section}}...{{/section}}</code></td>
  <td>Section (conditional/loop)</td>
</tr>
<tr>
  <td><code>{{^section}}...{{/section}}</code></td>
  <td>Inverted section (if false/empty)</td>
</tr>
<tr>
  <td><code>{{! comment }}</code></td>
  <td>Comment (not rendered)</td>
</tr>
<tr>
  <td><code>{{> partial}}</code></td>
  <td>Include partial template</td>
</tr>
</tbody>
</table>
<h3>18.4.3. Variables</h3>
<pre><code class="language-mustache">Hello {{name}}!
You have {{count}} messages.
</code></pre>
<p>
With context:
<pre><code class="language-json">{&quot;name&quot;: &quot;John&quot;, &quot;count&quot;: 5}
</code></pre>
<p>
Renders:
<pre><code class="language-text">Hello John!
You have 5 messages.
</code></pre>
<h3>18.4.4. Sections</h3>
<p>
Sections render based on the truthiness of the key:

</p>
<pre><code class="language-mustache">{{#hasMessages}}
  &lt;ul&gt;
  {{#messages}}
    &lt;li&gt;{{subject}}&lt;/li&gt;
  {{/messages}}
  &lt;/ul&gt;
{{/hasMessages}}

{{^hasMessages}}
  &lt;p&gt;No messages.&lt;/p&gt;
{{/hasMessages}}
</code></pre>
<p>
<strong>Section behavior:</strong>
<ul>
  <li><code>false</code> or empty array <code>[]</code>: Block not rendered</li>
  <li>Non-false value: Block rendered once (context switches to value)</li>
  <li>Non-empty array: Block rendered for each item</li>
</ul>
<h3>18.4.5. mORMot Extensions</h3>
<p>
mORMot adds useful features to standard Mustache:

</p>
<table>
<thead>
<tr>
  <th>Tag</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>{{.}}</code></td>
  <td>Current context value</td>
</tr>
<tr>
  <td><code>{{-index}}</code></td>
  <td>Current iteration index (1-based)</td>
</tr>
<tr>
  <td><code>{{-index0}}</code></td>
  <td>Current iteration index (0-based)</td>
</tr>
<tr>
  <td><code>{{#-first}}...{{/-first}}</code></td>
  <td>First item in loop</td>
</tr>
<tr>
  <td><code>{{#-last}}...{{/-last}}</code></td>
  <td>Last item in loop</td>
</tr>
<tr>
  <td><code>{{#-odd}}...{{/-odd}}</code></td>
  <td>Odd items (for zebra striping)</td>
</tr>
<tr>
  <td><code>{{<partial}}...{{/partial}}</code></td>
  <td>Inline partial definition</td>
</tr>
<tr>
  <td><code>{{"text}}</code></td>
  <td>Translatable text</td>
</tr>
<tr>
  <td><code>{{helperName value}}</code></td>
  <td>Expression helpers</td>
</tr>
</tbody>
</table>
<h3>18.4.6. Expression Helpers</h3>
<p>
Register helpers for common transformations:

</p>
<pre><code class="language-pascal">// Built-in helpers
{{DateTimeToText Article.CreatedAt}}
{{TimeLogToText Article.ModifiedAt}}
{{EnumToCaption Article.Status}}
{{BlobToBase64 Article.Image}}

// Custom helper registration
TSynMustache.HelpersGetStandardList.Add(
  &#x27;FormatCurrency&#x27;,
  procedure(const Value: variant; out Result: variant)
  begin
    Result := FormatFloat(&#x27;$#,##0.00&#x27;, Value);
  end
);
</code></pre>
<h3>18.4.7. ORM Integration</h3>
<p>
Register ORM classes as expression helpers:

</p>
<pre><code class="language-pascal">RegisterExpressionHelpersForTables(Views, RestServer, [TOrmAuthor, TOrmArticle]);
</code></pre>
<p>
Then in templates:
<pre><code class="language-mustache">{{#TOrmAuthor Article.AuthorID}}
  Author: {{Name}} ({{Email}})
{{/TOrmAuthor Article.AuthorID}}
</code></pre>
<p>
The <code>TOrmAuthor</code> helper automatically loads the record by ID.

</p>
<hr>
<h2>18.5. The Controller Layer</h2>
<h3>18.5.1. Defining Commands</h3>
<p>
The Controller is defined as an interface:

</p>
<pre><code class="language-pascal">type
  IMvcApplication = interface(IInvokable)
    [&#x27;{C48718BF-861B-448A-B593-8012DB51E15D}&#x27;]
    procedure Default(var Scope: variant);
    procedure Error(var Msg: RawUtf8; var Scope: variant);
  end;

  IBlogApplication = interface(IMvcApplication)
    [&#x27;{12345678-1234-1234-1234-123456789ABC}&#x27;]
    procedure ArticleView(ID: Integer; var WithComments: Boolean;
      out Article: TOrmArticle; out Author: variant; out Comments: TObjectList);
    procedure AuthorView(var ID: Integer; out Author: TOrmAuthor;
      out Articles: variant);
    function Login(const LogonName, Password: RawUtf8): TMvcAction;
    function Logout: TMvcAction;
  end;
</code></pre>
<h3>18.5.2. Parameter Directions</h3>
<table>
<thead>
<tr>
  <th>Direction</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>const</code></td>
  <td>Input only (from URL/form)</td>
</tr>
<tr>
  <td><code>var</code></td>
  <td>Input and output</td>
</tr>
<tr>
  <td><code>out</code></td>
  <td>Output only (to view)</td>
</tr>
<tr>
  <td><code>function: TMvcAction</code></td>
  <td>Redirect action</td>
</tr>
</tbody>
</table>
<h3>18.5.3. URI Mapping</h3>
<p>
Methods map to URIs automatically:

</p>
<table>
<thead>
<tr>
  <th>Method</th>
  <th>URI</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>Default</code></td>
  <td><code>/blog/default</code></td>
</tr>
<tr>
  <td><code>Error</code></td>
  <td><code>/blog/error</code></td>
</tr>
<tr>
  <td><code>ArticleView</code></td>
  <td><code>/blog/articleView?id=123&withComments=true</code></td>
</tr>
<tr>
  <td><code>Login</code></td>
  <td><code>/blog/login?logonName=john&password=xxx</code></td>
</tr>
</tbody>
</table>
<h3>18.5.4. Implementing the Controller</h3>
<pre><code class="language-pascal">type
  TBlogApplication = class(TMvcApplicationRest, IBlogApplication)
  public
    procedure Start(aRestModel: TRest; aInterface: PRttiInfo); override;
    procedure Default(var Scope: variant);
    procedure ArticleView(ID: Integer; var WithComments: Boolean;
      out Article: TOrmArticle; out Author: variant; out Comments: TObjectList);
    function Login(const LogonName, Password: RawUtf8): TMvcAction;
  end;

procedure TBlogApplication.ArticleView(ID: Integer; var WithComments: Boolean;
  out Article: TOrmArticle; out Author: variant; out Comments: TObjectList);
begin
  RestModel.Orm.Retrieve(ID, Article);
  if Article.ID = 0 then
    raise EMvcApplication.CreateGotoError(HTTP_NOTFOUND);

  Author := RestModel.Orm.RetrieveDocVariant(
    TOrmAuthor, &#x27;ID=?&#x27;, [Article.Author.ID], &#x27;Name,Email&#x27;);

  if WithComments then
  begin
    Comments.Free;
    Comments := RestModel.Orm.RetrieveList(TOrmComment, &#x27;Article=?&#x27;, [ID]);
  end;
end;

function TBlogApplication.Login(const LogonName, Password: RawUtf8): TMvcAction;
begin
  if ValidateCredentials(LogonName, Password) then
  begin
    CurrentSession.User := LogonName;
    Result.RedirectToMethodName := &#x27;Default&#x27;;
  end
  else
    raise EMvcApplication.CreateGotoError(&#x27;Invalid credentials&#x27;);
end;
</code></pre>
<h3>18.5.5. TMvcAction for Redirects</h3>
<p>
Methods returning <code>TMvcAction</code> don't render a view directly:

</p>
<pre><code class="language-pascal">type
  TMvcAction = record
    RedirectToMethodName: RawUtf8;
    RedirectToMethodParameters: RawUtf8;
    ReturnedStatus: Cardinal;
  end;

function TBlogApplication.Logout: TMvcAction;
begin
  CurrentSession.Clear;
  Result.RedirectToMethodName := &#x27;Default&#x27;;
  // or: Result.ReturnedStatus := HTTP_TEMPORARYREDIRECT;
end;
</code></pre>
<h3>18.5.6. Error Handling</h3>
<p>
Raise <code>EMvcApplication</code> to redirect to error page:

</p>
<pre><code class="language-pascal">// Redirect to error page with message
raise EMvcApplication.CreateGotoError(&#x27;Article not found&#x27;);

// Redirect to error page with HTTP status
raise EMvcApplication.CreateGotoError(HTTP_NOTFOUND);

// Redirect to another method
raise EMvcApplication.CreateGotoMethod(&#x27;Login&#x27;);
</code></pre>
<hr>
<h2>18.6. View Templates</h2>
<h3>18.6.1. Template Location</h3>
<p>
By default, templates are in a <code>Views</code> subfolder:

</p>
<pre><code class="language-text">MyApp/
├── MyApp.exe
└── Views/
    ├── Default.html
    ├── Error.html
    ├── ArticleView.html
    ├── AuthorView.html
    └── _partials/
        ├── header.html
        └── footer.html
</code></pre>
<h3>18.6.2. Template Structure</h3>
<pre><code class="language-html">&lt;!-- Default.html --&gt;
{{&gt;header}}

&lt;main&gt;
  &lt;h1&gt;{{Scope.Title}}&lt;/h1&gt;

  {{#Scope.Articles}}
  &lt;article&gt;
    &lt;h2&gt;&lt;a href=&quot;/blog/articleView?id={{ID}}&quot;&gt;{{Title}}&lt;/a&gt;&lt;/h2&gt;
    &lt;p&gt;{{Abstract}}&lt;/p&gt;
    &lt;small&gt;{{DateTimeToText CreatedAt}}&lt;/small&gt;
  &lt;/article&gt;
  {{/Scope.Articles}}

  {{^Scope.Articles}}
  &lt;p&gt;No articles published yet.&lt;/p&gt;
  {{/Scope.Articles}}
&lt;/main&gt;

{{&gt;footer}}
</code></pre>
<h3>18.6.3. Partials</h3>
<p>
Define reusable template fragments:

</p>
<pre><code class="language-html">&lt;!-- _partials/header.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;{{Main.Title}} - My Blog&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;nav&gt;
    &lt;a href=&quot;/blog/default&quot;&gt;Home&lt;/a&gt;
    {{#Main.User}}
    &lt;a href=&quot;/blog/logout&quot;&gt;Logout ({{.}})&lt;/a&gt;
    {{/Main.User}}
    {{^Main.User}}
    &lt;a href=&quot;/blog/login&quot;&gt;Login&lt;/a&gt;
    {{/Main.User}}
  &lt;/nav&gt;
</code></pre>
<h3>18.6.4. Static Files</h3>
<p>
Serve static content alongside templates:

</p>
<pre><code class="language-pascal">// Enable static file serving
fMainRunner := TMvcRunOnRestServer.Create(Self, &#x27;&#x27;, Server, &#x27;blog&#x27;, nil,
  [publishMvcInfo, publishStatic, bypassAuthentication]);
</code></pre>
<p>
Static files served from <code>.static</code> subfolder at <code>/blog/.static/*</code>.

</p>
<hr>
<h2>18.7. Session Management</h2>
<h3>18.7.1. Cookie-Based Sessions</h3>
<p>
MVC applications use cookie sessions:

</p>
<pre><code class="language-pascal">type
  TMvcSessionWithRestServer = class(TMvcSessionWithCookies)
  protected
    function GetCookie(out Value: PUtf8Char): Integer; override;
    procedure SetCookie(const Value: RawUtf8); override;
  end;
</code></pre>
<h3>18.7.2. Session Data</h3>
<p>
Access session data in controllers:

</p>
<pre><code class="language-pascal">procedure TBlogApplication.Default(var Scope: variant);
begin
  // Read session data
  if CurrentSession[&#x27;LoggedIn&#x27;] then
    Scope := _ObjFast([&#x27;User&#x27;, CurrentSession[&#x27;UserName&#x27;]]);
end;

function TBlogApplication.Login(const LogonName, Password: RawUtf8): TMvcAction;
begin
  if ValidateUser(LogonName, Password) then
  begin
    CurrentSession[&#x27;LoggedIn&#x27;] := True;
    CurrentSession[&#x27;UserName&#x27;] := LogonName;
    CurrentSession[&#x27;UserID&#x27;] := GetUserID(LogonName);
    Result.RedirectToMethodName := &#x27;Default&#x27;;
  end;
end;
</code></pre>
<hr>
<h2>18.8. Debugging MVC Applications</h2>
<h3>18.8.1. The mvc-info Page</h3>
<p>
Access <code>/blog/mvc-info</code> to see:
<ul>
  <li>All registered commands</li>
  <li>Parameter types and directions</li>
  <li>View data context structure</li>
</ul>
<pre><code class="language-text">/blog/Default?Scope=..[variant]..
/blog/Error?Msg=..[string]..&amp;Scope=..[variant]..
/blog/ArticleView?ID=..[integer]..&amp;WithComments=..[boolean]..

ArticleView context:
{{WithComments}}: boolean
{{Article}}: TOrmArticle
{{Author}}: variant
{{Comments}}: TObjectList
</code></pre>
<h3>18.8.2. JSON Context View</h3>
<p>
Append <code>/json</code> to any URL to see the raw data context:

</p>
<pre><code class="language-text">/blog/articleView?id=123           → HTML page
/blog/articleView/json?id=123      → JSON data context
</code></pre>
<hr>
<h2>Summary</h2>
<p>
The MVC pattern in mORMot 2 provides:

</p>
<ul>
  <li><strong>Model</strong>: <code>TOrm</code> classes with full ORM capabilities</li>
  <li><strong>View</strong>: Mustache templates for logic-less rendering</li>
  <li><strong>Controller</strong>: Interface methods mapped to URIs</li>
</ul>
Key features:
<ul>
  <li><strong>Automatic routing</strong>: Methods become URIs</li>
  <li><strong>Type-safe parameters</strong>: Compile-time checking</li>
  <li><strong>Expression helpers</strong>: Transform data in templates</li>
  <li><strong>Session management</strong>: Cookie-based state</li>
  <li><strong>Debug tools</strong>: mvc-info and JSON context views</li>
</ul>
This architecture cleanly separates concerns while providing the power of mORMot's ORM and SOA capabilities.

</p>
<hr>
<h2>Navigation</h2>
<table>
<thead>
<tr>
  <th>Previous</th>
  <th>Index</th>
  <th>Next</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="mORMot2-SAD-Chapter-17.html">Chapter 17: Cross-Platform Clients</a></td>
  <td><a href="mORMot2-SAD-Index.html">Index</a></td>
  <td><a href="mORMot2-SAD-Chapter-19.html">Chapter 19: MVC/MVVM Web Applications</a></td>
</tr>
</tbody>
</table>
</body>
</html>
