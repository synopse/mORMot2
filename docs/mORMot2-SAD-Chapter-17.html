<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Usage</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 { color: #2c3e50; margin-top: 1.5em; }
        h1 { border-bottom: 2px solid #3498db; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em; }
        code {
            background-color: #f8f8f8;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f8f8;
            padding: 1em;
            overflow-x: auto;
            border-radius: 5px;
            border: 1px solid #ddd;
            line-height: 1.1;
            font-family: "Cascadia Code", "Fira Code", "Source Code Pro", "DejaVu Sans Mono", "Consolas", "Lucida Console", "Courier New", monospace;
            font-size: 13px;
            letter-spacing: 0;
            font-variant-ligatures: none;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            line-height: 1.1;
            font-family: inherit;
            letter-spacing: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            text-align: left;
        }
        th { background-color: #f8f8f8; }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            color: #666;
        }
        a { color: #3498db; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .toc { background: #f8f8f8; padding: 1em; border-radius: 5px; }
        .toc ul { list-style: none; padding-left: 1em; }
        .note { background: #fff3cd; padding: 1em; border-radius: 5px; margin: 1em 0; }
        .warning { background: #f8d7da; padding: 1em; border-radius: 5px; margin: 1em 0; }
    </style>
</head>
<body>
<p>
﻿# 17. Cross-Platform Clients

</p>
<p>
<em>Reaching Beyond Windows</em>

</p>
<p>
mORMot 2 is designed from the ground up as a <strong>cross-platform framework</strong>. The core libraries compile natively on Windows, Linux, macOS, FreeBSD, and Android using either Delphi or Free Pascal. This chapter covers strategies for consuming mORMot services from various platforms and generating client code.

</p>
<hr>
<h2>17.1. Native Cross-Platform Support</h2>
<h3>17.1.1. mORMot 2 Platform Coverage</h3>
<p>
Unlike mORMot 1 (which required separate <code>SynCrossPlatform<em></code> units), mORMot 2's main units are inherently cross-platform:

</p>
<table>
<thead>
<tr>
  <th>Platform</th>
  <th>Delphi</th>
  <th>Free Pascal</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Windows (32/64-bit)</td>
  <td>✅</td>
  <td>✅</td>
</tr>
<tr>
  <td>Linux (x86_64, aarch64)</td>
  <td>✅ (Delphi 12+)</td>
  <td>✅</td>
</tr>
<tr>
  <td>macOS (x86_64, aarch64)</td>
  <td>✅</td>
  <td>✅</td>
</tr>
<tr>
  <td>FreeBSD</td>
  <td>—</td>
  <td>✅</td>
</tr>
<tr>
  <td>Android</td>
  <td>✅ (FireMonkey)</td>
  <td>✅</td>
</tr>
<tr>
  <td>iOS</td>
  <td>✅ (FireMonkey)</td>
  <td>—</td>
</tr>
</tbody>
</table>
<h3>17.1.2. Core Cross-Platform Units</h3>
<p>
The <code>mormot.core.</em></code> units provide the foundation:

</p>
<table>
<thead>
<tr>
  <th>Unit</th>
  <th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>mormot.core.base</code></td>
  <td>Base types, memory management</td>
</tr>
<tr>
  <td><code>mormot.core.os</code></td>
  <td>OS abstraction (files, threads, processes)</td>
</tr>
<tr>
  <td><code>mormot.core.unicode</code></td>
  <td>UTF-8/UTF-16 handling</td>
</tr>
<tr>
  <td><code>mormot.core.text</code></td>
  <td>Text processing, formatting</td>
</tr>
<tr>
  <td><code>mormot.core.buffers</code></td>
  <td>Binary data handling</td>
</tr>
<tr>
  <td><code>mormot.core.data</code></td>
  <td>Collections, dynamic arrays</td>
</tr>
<tr>
  <td><code>mormot.core.json</code></td>
  <td>JSON parsing and generation</td>
</tr>
<tr>
  <td><code>mormot.core.variants</code></td>
  <td>TDocVariant for flexible JSON</td>
</tr>
<tr>
  <td><code>mormot.core.rtti</code></td>
  <td>Cross-platform RTTI</td>
</tr>
<tr>
  <td><code>mormot.core.interfaces</code></td>
  <td>Interface invocation, stubs, mocks</td>
</tr>
</tbody>
</table>
These units have <strong>zero GUI dependencies</strong> and work identically across all supported platforms.

</p>
<h3>17.1.3. Network Layer</h3>
<p>
HTTP client support via <code>mormot.net.*</code>:

</p>
<pre><code class="language-pascal">uses
  mormot.net.client,
  mormot.rest.http.client;

var
  Client: TRestHttpClientSocket;
begin
  // Works on Windows, Linux, macOS, etc.
  Client := TRestHttpClientSocket.Create(&#x27;api.example.com&#x27;, &#x27;443&#x27;, Model, True);
  try
    Client.ServiceDefine([IMyService], sicShared);
    // Use services...
  finally
    Client.Free;
  end;
end;
</code></pre>
<p>
Available HTTP client classes:

</p>
<table>
<thead>
<tr>
  <th>Class</th>
  <th>Transport</th>
  <th>Platform</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>TRestHttpClientSocket</code></td>
  <td>Raw sockets</td>
  <td>All</td>
</tr>
<tr>
  <td><code>TRestHttpClientWebSockets</code></td>
  <td>WebSocket</td>
  <td>All</td>
</tr>
<tr>
  <td><code>TRestHttpClientWinHttp</code></td>
  <td>WinHTTP API</td>
  <td>Windows</td>
</tr>
<tr>
  <td><code>TRestHttpClientCurl</code></td>
  <td>libcurl</td>
  <td>Linux/macOS</td>
</tr>
</tbody>
</table>
<hr>
<h2>17.2. Generating Client Wrappers</h2>
<h3>17.2.1. The Code Generation Framework</h3>
<p>
mORMot 2 includes a powerful code generation system in <code>mormot.soa.codegen.pas</code> that creates client wrappers from server definitions using Mustache templates.

</p>
<p>
Key functions:

</p>
<table>
<thead>
<tr>
  <th>Function</th>
  <th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>ContextFromModel()</code></td>
  <td>Extract ORM/SOA metadata as JSON</td>
</tr>
<tr>
  <td><code>WrapperFromModel()</code></td>
  <td>Generate code from Mustache template</td>
</tr>
<tr>
  <td><code>WrapperMethod()</code></td>
  <td>HTTP handler for browser-based generation</td>
</tr>
<tr>
  <td><code>AddToServerWrapperMethod()</code></td>
  <td>Add wrapper endpoint to server</td>
</tr>
</tbody>
</table>
<h3>17.2.2. Publishing the Wrapper Endpoint</h3>
<pre><code class="language-pascal">program MyServer;

uses
  mormot.rest.server,
  mormot.rest.http.server,
  mormot.soa.codegen;

var
  Server: TRestServerDB;
  HttpServer: TRestHttpServer;
begin
  Server := TRestServerDB.Create(Model, &#x27;data.db3&#x27;);
  try
    Server.ServiceDefine(TMyService, [IMyService], sicShared);

    // Add wrapper generation endpoint
    AddToServerWrapperMethod(Server, [&#x27;./templates&#x27;, &#x27;../templates&#x27;]);

    HttpServer := TRestHttpServer.Create(&#x27;8080&#x27;, [Server]);
    try
      WriteLn(&#x27;Wrapper available at http://localhost:8080/root/wrapper&#x27;);
      ReadLn;
    finally
      HttpServer.Free;
    end;
  finally
    Server.Free;
  end;
end.
</code></pre>
<h3>17.2.3. Using the Web Interface</h3>
<p>
Navigate to <code>http://localhost:8080/root/wrapper</code> in your browser:

</p>
<pre><code class="language-text">Client Wrappers
===============

Available Templates:
- Delphi
  mORMotClient.pas - download as file | see as text | see template

- TypeScript
  mORMotClient.ts - download as file | see as text | see template

- OpenAPI
  openapi.json - download as file | see as text | see template

Template context (JSON)
</code></pre>
<h3>17.2.4. Mustache Template System</h3>
<p>
Templates use the Mustache logic-less syntax:

</p>
<pre><code class="language-mustache">// Generated client for {{root}} API
unit {{filename}};

interface

uses
  mormot.core.base,
  mormot.rest.client;

type
{{#services}}
  {{interfaceName}} = interface(IInvokable)
    [&#x27;{{{guid}}}&#x27;]
  {{#methods}}
    {{declaration}};
  {{/methods}}
  end;

{{/services}}

implementation

{{#services}}
// {{interfaceName}} implementation
{{#methods}}
function T{{serviceName}}.{{methodName}}({{args}}): {{resultType}};
begin
  // Generated stub code
end;

{{/methods}}
{{/services}}

end.
</code></pre>
<h3>17.2.5. Available Template Variables</h3>
<p>
The context includes:

</p>
<table>
<thead>
<tr>
  <th>Variable</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>{{root}}</code></td>
  <td>API root URI</td>
</tr>
<tr>
  <td><code>{{port}}</code></td>
  <td>Server port</td>
</tr>
<tr>
  <td><code>{{filename}}</code></td>
  <td>Output filename</td>
</tr>
<tr>
  <td><code>{{orm}}</code></td>
  <td>Array of ORM classes</td>
</tr>
<tr>
  <td><code>{{services}}</code></td>
  <td>Array of service interfaces</td>
</tr>
<tr>
  <td><code>{{#service.methods}}</code></td>
  <td>Methods within service</td>
</tr>
<tr>
  <td><code>{{typeDelphi}}</code></td>
  <td>Delphi type name</td>
</tr>
<tr>
  <td><code>{{typeTS}}</code></td>
  <td>TypeScript type name</td>
</tr>
<tr>
  <td><code>{{typeCS}}</code></td>
  <td>C# type name</td>
</tr>
<tr>
  <td><code>{{typeJava}}</code></td>
  <td>Java type name</td>
</tr>
</tbody>
</table>
<hr>
<h2>17.3. Delphi/FPC Native Clients</h2>
<h3>17.3.1. Direct mORMot Usage</h3>
<p>
The simplest approach — use mORMot directly on any supported platform:

</p>
<pre><code class="language-pascal">program CrossPlatformClient;

{$APPTYPE CONSOLE}

uses
  mormot.core.base,
  mormot.core.os,
  mormot.orm.core,
  mormot.rest.http.client,
  MyServiceInterface;

var
  Client: TRestHttpClientSocket;
  Service: IMyService;
begin
  Client := TRestHttpClientSocket.Create(&#x27;server.example.com&#x27;, &#x27;8080&#x27;,
    TOrmModel.Create([], &#x27;api&#x27;));
  try
    Client.ServiceDefine([IMyService], sicShared);

    if Client.Services.Resolve(IMyService, Service) then
      WriteLn(&#x27;Result: &#x27;, Service.Calculate(10, 20));
  finally
    Client.Free;
  end;
end.
</code></pre>
<p>
This compiles and runs identically on Windows, Linux, and macOS.

</p>
<h3>17.3.2. Generated Client Wrapper</h3>
<p>
For projects that can't include full mORMot dependencies, use generated wrappers:

</p>
<pre><code class="language-pascal">// Generated mORMotClient.pas
unit mORMotClient;

interface

uses
  mormot.core.base,
  mormot.rest.client;

type
  ICalculator = interface(IInvokable)
    [&#x27;{9A60C8ED-CEB2-4E09-87D4-4A16F496E5FE}&#x27;]
    function Add(n1, n2: Integer): Integer;
    function Multiply(n1, n2: Int64): Int64;
  end;

/// Create a connected client instance
function GetClient(const aServer: RawUtf8;
  const aPort: RawUtf8 = &#x27;8080&#x27;): TRestHttpClientSocket;

implementation

function GetClient(const aServer, aPort: RawUtf8): TRestHttpClientSocket;
begin
  Result := TRestHttpClientSocket.Create(aServer, aPort,
    TOrmModel.Create([], &#x27;api&#x27;));
  Result.ServiceDefine([ICalculator], sicShared);
end;

end.
</code></pre>
<h3>17.3.3. FPC-Specific Generation</h3>
<p>
For Free Pascal, additional RTTI registration may be needed:

</p>
<pre><code class="language-pascal">procedure ComputeFPCInterfacesUnit(const Path: array of TFileName;
  DestFileName: TFileName = &#x27;&#x27;);
</code></pre>
<p>
This generates a unit with explicit interface registration to work around FPC RTTI limitations.

</p>
<hr>
<h2>17.4. REST/JSON Clients (Any Language)</h2>
<h3>17.4.1. Protocol Overview</h3>
<p>
mORMot services use standard HTTP with JSON:

</p>
<p>
<strong>Request Format:</strong>
<pre><code class="language-text">GET /api/Calculator/Add?n1=10&amp;n2=20 HTTP/1.1
Host: server.example.com
</code></pre>
<p>
<strong>Response Format:</strong>
<pre><code class="language-json">{&quot;result&quot;: 30}
</code></pre>
<p>
For POST requests with complex parameters:
<pre><code class="language-text">POST /api/Calculator.Add HTTP/1.1
Content-Type: application/json

[10, 20]
</code></pre>
<h3>17.4.2. Authentication</h3>
<p>
mORMot's default authentication uses a challenge-response protocol:

</p>
<p>
1. Client requests timestamp: <code>GET /api/auth</code>
2. Server returns: <code>{"result": "1234567890"}</code>
3. Client computes: <code>HMAC-SHA256(password, timestamp + username)</code>
4. Client authenticates: <code>GET /api/auth?UserName=xxx&PasswordHashHexa=yyy&ClientNonce=zzz</code>
5. Server returns session info

</p>
<p>
For simpler integration, consider:
<ul>
  <li><strong>Basic Auth</strong>: <code>Authorization: Basic base64(user:pass)</code></li>
  <li><strong>Bearer Token</strong>: <code>Authorization: Bearer jwt_token</code></li>
  <li><strong>No Auth</strong>: <code>Server.AuthenticationRegister(TRestServerAuthenticationNone)</code></li>
</ul>
<h3>17.4.3. TypeScript/JavaScript Client</h3>
<p>
Example generated TypeScript client:

</p>
<pre><code class="language-typescript">// mORMotClient.ts
export interface ICalculator {
  add(n1: number, n2: number): Promise&lt;number&gt;;
  multiply(n1: number, n2: number): Promise&lt;number&gt;;
}

export class CalculatorClient implements ICalculator {
  constructor(private baseUrl: string) {}

  async add(n1: number, n2: number): Promise&lt;number&gt; {
    const response = await fetch(
      `${this.baseUrl}/Calculator/Add?n1=${n1}&amp;n2=${n2}`
    );
    const data = await response.json();
    return data.result;
  }

  async multiply(n1: number, n2: number): Promise&lt;number&gt; {
    const response = await fetch(
      `${this.baseUrl}/Calculator/Multiply?n1=${n1}&amp;n2=${n2}`
    );
    const data = await response.json();
    return data.result;
  }
}

// Usage
const calc = new CalculatorClient(&#x27;http://localhost:8080/api&#x27;);
const sum = await calc.add(10, 20);
</code></pre>
<h3>17.4.4. Python Client</h3>
<pre><code class="language-python">import requests

class CalculatorClient:
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip(&#x27;/&#x27;)

    def add(self, n1: int, n2: int) -&gt; int:
        response = requests.get(
            f&quot;{self.base_url}/Calculator/Add&quot;,
            params={&quot;n1&quot;: n1, &quot;n2&quot;: n2}
        )
        return response.json()[&quot;result&quot;]

    def multiply(self, n1: int, n2: int) -&gt; int:
        response = requests.get(
            f&quot;{self.base_url}/Calculator/Multiply&quot;,
            params={&quot;n1&quot;: n1, &quot;n2&quot;: n2}
        )
        return response.json()[&quot;result&quot;]

# Usage
calc = CalculatorClient(&quot;http://localhost:8080/api&quot;)
print(calc.add(10, 20))  # 30
</code></pre>
<h3>17.4.5. C# Client</h3>
<pre><code class="language-csharp">using System.Net.Http.Json;

public interface ICalculator
{
    Task&lt;int&gt; Add(int n1, int n2);
    Task&lt;long&gt; Multiply(long n1, long n2);
}

public class CalculatorClient : ICalculator
{
    private readonly HttpClient _client;
    private readonly string _baseUrl;

    public CalculatorClient(string baseUrl)
    {
        _client = new HttpClient();
        _baseUrl = baseUrl.TrimEnd(&#x27;/&#x27;);
    }

    public async Task&lt;int&gt; Add(int n1, int n2)
    {
        var response = await _client.GetFromJsonAsync&lt;ResultWrapper&lt;int&gt;&gt;(
            $&quot;{_baseUrl}/Calculator/Add?n1={n1}&amp;n2={n2}&quot;);
        return response.Result;
    }

    public async Task&lt;long&gt; Multiply(long n1, long n2)
    {
        var response = await _client.GetFromJsonAsync&lt;ResultWrapper&lt;long&gt;&gt;(
            $&quot;{_baseUrl}/Calculator/Multiply?n1={n1}&amp;n2={n2}&quot;);
        return response.Result;
    }

    private record ResultWrapper&lt;T&gt;(T Result);
}
</code></pre>
<hr>
<h2>17.5. OpenAPI/Swagger Integration</h2>
<h3>17.5.1. Generating OpenAPI Specification</h3>
<p>
Create a Mustache template for OpenAPI 3.0:

</p>
<pre><code class="language-mustache">{
  &quot;openapi&quot;: &quot;3.0.0&quot;,
  &quot;info&quot;: {
    &quot;title&quot;: &quot;{{root}} API&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
  },
  &quot;servers&quot;: [
    {&quot;url&quot;: &quot;http://localhost:{{port}}/{{root}}&quot;}
  ],
  &quot;paths&quot;: {
{{#services}}
{{#methods}}
    &quot;/{{../serviceName}}/{{methodName}}&quot;: {
      &quot;get&quot;: {
        &quot;operationId&quot;: &quot;{{../serviceName}}_{{methodName}}&quot;,
        &quot;parameters&quot;: [
{{#args}}
          {
            &quot;name&quot;: &quot;{{argName}}&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;schema&quot;: {&quot;type&quot;: &quot;{{openApiType}}&quot;}
          }{{^last}},{{/last}}
{{/args}}
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Success&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;type&quot;: &quot;object&quot;,
                  &quot;properties&quot;: {
                    &quot;result&quot;: {&quot;type&quot;: &quot;{{openApiResultType}}&quot;}
                  }
                }
              }
            }
          }
        }
      }
    }{{^last}},{{/last}}
{{/methods}}
{{/services}}
  }
}
</code></pre>
<h3>17.5.2. Using with Swagger UI</h3>
<p>
Once you have the OpenAPI spec, integrate with Swagger UI:

</p>
<pre><code class="language-pascal">// Add static file serving for Swagger UI
procedure TMyServer.SwaggerUI(Ctxt: TRestServerUriContext);
begin
  Ctxt.ReturnFileFromFolder(&#x27;./swagger-ui/&#x27;, True, &#x27;index.html&#x27;);
end;
</code></pre>
<hr>
<h2>17.6. WebSocket Clients</h2>
<h3>17.6.1. JavaScript WebSocket Client</h3>
<p>
For bidirectional communication:

</p>
<pre><code class="language-javascript">class MorMotWebSocket {
  constructor(url) {
    this.ws = new WebSocket(url);
    this.callbacks = new Map();
    this.callId = 0;

    this.ws.onmessage = (event) =&gt; {
      const response = JSON.parse(event.data);
      const callback = this.callbacks.get(response.id);
      if (callback) {
        callback(response.result);
        this.callbacks.delete(response.id);
      }
    };
  }

  call(service, method, params) {
    return new Promise((resolve) =&gt; {
      const id = ++this.callId;
      this.callbacks.set(id, resolve);
      this.ws.send(JSON.stringify({
        id,
        method: `${service}.${method}`,
        params
      }));
    });
  }
}

// Usage
const ws = new MorMotWebSocket(&#x27;ws://localhost:8080/api&#x27;);
const result = await ws.call(&#x27;Calculator&#x27;, &#x27;Add&#x27;, [10, 20]);
</code></pre>
<h3>17.6.2. Handling Callbacks</h3>
<p>
For server-to-client callbacks:

</p>
<pre><code class="language-javascript">ws.onmessage = (event) =&gt; {
  const msg = JSON.parse(event.data);

  if (msg.callback) {
    // Server-initiated callback
    handleCallback(msg.callback, msg.params);
  } else if (msg.id) {
    // Response to our request
    resolveRequest(msg.id, msg.result);
  }
};

function handleCallback(name, params) {
  switch (name) {
    case &#x27;IProgress.Update&#x27;:
      updateProgressBar(params.percent);
      break;
    case &#x27;IProgress.Completed&#x27;:
      showComplete(params.success);
      break;
  }
}
</code></pre>
<hr>
<h2>17.7. Mobile Considerations</h2>
<h3>17.7.1. Network Connectivity</h3>
<p>
Mobile apps must handle:
<ul>
  <li>Intermittent connectivity</li>
  <li>High latency</li>
  <li>Battery constraints</li>
</ul>
<pre><code class="language-pascal">// Retry logic with exponential backoff
function CallWithRetry(Client: TRestHttpClientSocket;
  const Method: RawUtf8; MaxRetries: Integer = 3): RawJson;
var
  Attempt: Integer;
  Delay: Integer;
begin
  Delay := 100; // Initial delay in ms
  for Attempt := 1 to MaxRetries do
  try
    Result := Client.CallBackGetResult(Method, []);
    Exit;
  except
    on E: Exception do
    begin
      if Attempt = MaxRetries then
        raise;
      Sleep(Delay);
      Delay := Delay * 2; // Exponential backoff
    end;
  end;
end;
</code></pre>
<h3>17.7.2. Data Caching</h3>
<p>
For offline support:

</p>
<pre><code class="language-pascal">type
  TCachedClient = class
  private
    fClient: TRestHttpClientSocket;
    fCache: TDocVariantData;
  public
    function GetData(const Key: RawUtf8): Variant;
  end;

function TCachedClient.GetData(const Key: RawUtf8): Variant;
begin
  // Try cache first
  if fCache.GetValueByPath(Key, Result) then
    Exit;

  // Fetch from server
  try
    Result := fClient.CallBackGetResult(&#x27;GetData&#x27;, [&#x27;key&#x27;, Key]);
    fCache.AddValue(Key, Result);
  except
    // Return cached data even if stale
    Result := fCache.Value[Key];
  end;
end;
</code></pre>
<h3>17.7.3. Delphi FireMonkey</h3>
<p>
mORMot works with FireMonkey for iOS/Android:

</p>
<pre><code class="language-pascal">uses
  mormot.rest.http.client,
  FMX.Forms;

procedure TMainForm.ConnectButtonClick(Sender: TObject);
begin
  // Same code works on mobile
  fClient := TRestHttpClientSocket.Create(
    EditServer.Text,
    EditPort.Text,
    fModel
  );
  fClient.ServiceDefine([IMyService], sicShared);
end;
</code></pre>
<p>
<strong>Note</strong>: Ensure you're using <code>TRestHttpClientSocket</code> or <code>TRestHttpClientCurl</code> on mobile, not Windows-specific classes.

</p>
<hr>
<h2>17.8. Best Practices</h2>
<h3>17.8.1. API Versioning</h3>
<p>
Include version in your API root:

</p>
<pre><code class="language-pascal">// Server
Server := TRestServerDB.Create(Model, &#x27;data.db3&#x27;);
Server.Model.Root := &#x27;api/v1&#x27;;

// Client
Client := TRestHttpClientSocket.Create(&#x27;server&#x27;, &#x27;8080&#x27;,
  TOrmModel.Create([], &#x27;api/v1&#x27;));
</code></pre>
<h3>17.8.2. Error Handling</h3>
<p>
Standardize error responses:

</p>
<pre><code class="language-json">{
  &quot;errorCode&quot;: 400,
  &quot;errorText&quot;: &quot;Invalid parameter: n1 must be positive&quot;
}
</code></pre>
<p>
Handle on client:
<pre><code class="language-typescript">async function callService(method: string, params: any): Promise&lt;any&gt; {
  const response = await fetch(`${baseUrl}/${method}?${new URLSearchParams(params)}`);
  const data = await response.json();

  if (data.errorCode) {
    throw new Error(`${data.errorCode}: ${data.errorText}`);
  }

  return data.result;
}
</code></pre>
<h3>17.8.3. Security</h3>
<p>
1. <strong>Always use HTTPS</strong> in production
2. <strong>Validate input</strong> on server side
3. <strong>Use authentication</strong> for sensitive operations
4. <strong>Rate limiting</strong> to prevent abuse
5. <strong>CORS headers</strong> for browser clients:

</p>
<pre><code class="language-pascal">HttpServer.AccessControlAllowOrigin := &#x27;*&#x27;; // Or specific origins
</code></pre>
<hr>
<h2>Summary</h2>
<p>
mORMot 2's cross-platform capabilities:

</p>
<ul>
  <li><strong>Native support</strong>: Same code compiles on Windows, Linux, macOS, Android</li>
  <li><strong>Code generation</strong>: Mustache-based templates for any target language</li>
  <li><strong>Standard protocols</strong>: HTTP/JSON for universal compatibility</li>
  <li><strong>OpenAPI integration</strong>: Generate documentation and client SDKs</li>
  <li><strong>WebSocket support</strong>: Bidirectional communication across platforms</li>
  <li><strong>Mobile-ready</strong>: Works with Delphi FireMonkey and FPC</li>
</ul>
The framework's clean REST/JSON protocol means any HTTP client can consume mORMot services, while native Pascal clients get the full type-safe experience with automatic stub generation.

</p>
<hr>
<h2>Navigation</h2>
<table>
<thead>
<tr>
  <th>Previous</th>
  <th>Index</th>
  <th>Next</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="mORMot2-SAD-Chapter-16.html">Chapter 16: Client-Server Services via Interfaces</a></td>
  <td><a href="mORMot2-SAD-Index.html">Index</a></td>
  <td><a href="mORMot2-SAD-Chapter-18.html">Chapter 18: The MVC Pattern</a></td>
</tr>
</tbody>
</table>
</body>
</html>
